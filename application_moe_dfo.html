<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABN8AAAGRCAYAAABVBRUGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAV3pJREFUeNrs3T+UE0m+KOiEqXOYtabaG2+Et14X3l0LlXfXovDuWl1lrgV4uxZgPguwdteqwnr7LApvn4Ww9j0LjXc91N5dqzXe1DnQvRkQ6k6EpMxU/k993zk61U2VpMiIyPjzy8iMJAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgKM7d07S14sepec8vJQMAAAAAIMWA2+/pK/f+hCAi4G33+LrXAkBAAAAMEhrgbfOA159Sw8AAAAA7GVLoGv1mnaQnuMd6TlXYgAAzbstCwAAqguBt/THu/R1vOVP3oRgWMvJerMjPZcCcAAAzRN8AwCoqEDgLYm/e9Nimp6lP6Y5fyYABwDQsD/JAgCA/RUMvK1Mbh8d/ePXz5//Wwtp+s8F//wsTdPPaZrmShMAoH63ZAEAwH5KBt5Wlunr7qebm2WD6fqQ/jgp+baLNE1XShUAoF5uOwUA2MOegbck/v2LBtN1npQPvAVuQQUAaICVbwAAJVUIvGWF1W+LmtMV0vOxYrqsgAMAqJGVbwAAJdQUeAueNpC8xzWkywo4AIAaWfkGAFBQjYG3lVpXv6Xp+6XGtFkBBwBQAyvfAAAKaCDwFjytMX3nNafNCjgAgBpY+QYAkKOhwFtQ286ne+5wWoQVcAAAFVj5BgCwQ4OBtyR+5lkNaZwkzQTeAivgAAAqEHwDANii4cDbyoMaPuOs4awQgAMA2JPbTgEANmgp8PbFp5ubWxXT2tQtp+vcggoAUJKVbwAAa9oMvMXvO6vw3pDGk5ayxgo4AICSBN8AADLaDrxF9yu8d9pyFgnAAQCUIPgGABB1FHgLqqxcu99BVgnAAQAUJPgGAJB0GngLphXee9JRlgnAAQAUIPgGABy8jgNvqzRM9nzrSYdZJwAHAJBD8A0AOGh9CLxFkz3f13W6BeAAAHYQfAMADlaPAm/BZI/0T3uSlQJwAABbCL4BAAepZ4G3YDLwLBWAAwDYQPANADg4PQy8jYUAHADAGsE3AOCgjCzwdtLDNAnAAQBkCL4BAAdjhCve+nocAnAAAJHgGwBwEEZ6q+myx2kTgAMASATfAIADMOJnvM17nj4BOADg4Am+AQCjZnOFzgnAAQAHTfANABitgQXeFiMuCgE4AOBgCb4BAKM0wBVviz3eMx9QkQjAAQAHSfANABidgd5quij7hk83N8uBFY0AHABwcATfAIBRGeoz3j7d3Cz2fOtsYEUkAAcAHBTBNwBgNAa8ucKswnvnAywqATgA4GAIvgEAozDwXU2rBND+PtAiE4ADAA6C4BsAMHgDD7wF7yu8dzbgohOAAwBG75YsAACGbASBt/C8t1sV8+Bj+mMy4GK8SPPgSm0GAMbIyjcAYLDGEHhLXffkM7pkBRwAMFqCbwDAII0k8Ba8reEzXo+gSAXgAIBRctspADA4Iwq8LdPX3U83N8sa8uRD+uNkBMXrFlQAYFSsfAMABmVEgbfguo7AW/RqJEVsBRwAMCpWvgEAgzGywFsQVr0tasqbkCcfR5Q3VsABAKPwJ1kAAAzBCANvV59ubmp7Vtuvnz//8/bR0f+Q/ud0JPlzlh7Pz+lxzdV+AGDIrHwDAHpvhIG3oLZVb5l8Gtvqt8AKOABg0Kx8AwB6baSBt1pXva2McPVbYAUcADBoVr4BAL010sBbbTuc7si3sPptMrLqYAUcADBIdjsFAHpppIG34HmTgbfoYoRVwi6oAMAgue0UAOidEQfeZp9ubv7Xpr/k18+fF7ePjkLe/cvI8s8tqADA4Ai+AQC9MuLAW1jt9j+F57K18WW3j47+e/rjX9PXX0eWjwJwAMCgCL4BAL0Rd+v8kIwv8Bb8z59ubv69rS+Lmy+EANy/pa8/jywvBeAAgMHwzDcAoBdi4G2MK96CsFnArO0vTb8zBKcuRlplPAMOABgEK98AgF64fXT0n9Mf0xEe2stPNzf/qasv//Xz538Pq8TS/zwbYd5aAQcA9J7gGwDQuaM7dx6nPx6P8NCu2thgIU8ITgnAAQB0Q/ANAOhU3GDhzQgPLQTeenPLpwAcAEA3BN8AgM7E57yFwNvYduQMz3h73rdECcABALRP8A0A6Mzto6P/Lfm6G+eYhMDbVV8TJwAHANAuwTcAoDVhpduvnz//M/73JBnf7aa9DrytCMABALTntiwAANoQN1XIuhzZIQ4i8LYS03ox0up2mda3c2cdANAHt2QBANC0ozt3nqU/Xn66uVnG/5+mP96N5PDCMZ2mxzYfaNmcJ+MLhK4MKiAKAIyT204BgEYd3bnzIv3xXz7d3CxW/3b76GgsmywMOvAWuAUVAKBZbjsFABpzdOdOWFH1PhucSv8tBHlORnB4gw+8rbgFFQCgOVa+AQCNiIG3nz/d3Pyf2X+/fXT0f6Q/JgM/vNEE3lasgAMAaIZnvgEAtYuBt5NPNzf31v59mgz/WW8hgHO6en7dCMvuPPEMOACA+sZXsgAAqHVw8TXwdp6+7m349U8DP7xRB96CEJxKyzD85xgDcOEW1EQADgBok2e+AQC1yQTeXq7fkpn+7jgZ9i2Now+8rXgGHABAfTzzDQCoRSbwFoJTD3/9/Pmf2d/fPjr6t/THvw308A4m8LbiGXAAAPWw8g0AqCwTeAtebQlSPRjo4V2FZ9cdUuBtxQo4AIDqbLgAAFSyFngLAaq764GqeMvpLwM8vBB4u1DGNmEAANiXlW8AwN7WAm/B9ZYVYtMBHp7AW2QFHADA/gTfAIC9bAi8Bc+3/Pn9gR2ewNsaATgAgP0IvgEApW0JvM0/3dwstrxlOqDDuxB420wADgCgPME3AKCULYG34PWOt50M5PA8/yuHABwAQDmCbwBAYTsCb8Fsy3umAzk8gbeCBOAAAIoTfAMACskJvC0/3dzMt/xuMoDDE3grSQAOAKAYwTcAIFdO4C2Y7fjdpMeHFnZmvSfwth8BOACAfIJvAMBOBQJvwd93/O7Hnh5aCLyd7lixRwECcAAAuwm+AQBbFQy8BbsCWMc9PDSBtxoJwAEAbCf4BgBsVCLwFiwHdGgCbw0QgAMA2EzwDQD4TsnAWwi8zAZyaCHgdlfgrRkCcAAA3xN8AwC+UTbwNiAh4BZWvC2VcnME4AAAviX4BgD8TuCNOgjAAQD8QfANAPhC4I06CcABAHwl+AYAjDnwdvXp5uaewFs3BOAAAATfAODgjTzwdqGEuyUABwAcOsE3ADhgLQXeuthZVOCtRwTgAIBDJvgGAAeqzsBb+lknO379j5YPTeCthwTgAIBDJfgGAAeogRVvxzt+N2vx0C4E3vpLAA4AOESCbwBwYBq61XTXyrdFS4d2EYM79JgAHABwaATfAOCANPiMtx+3/eLTzc0iaT4AJ/A2IAJwAMAhEXwDgAPR8OYKJzm/nzV4aAJvAyQABwAcCsE3ADgALexqepJ+x67nvr1v4DuX6etU4G24BOAAgEMg+AYAI9dC4G3lbMfvrmv+rlXgbaaEh00ADgAYuz/JAgAYrxYDb8Hy18+f3276Rfrv/7x9dDRJ8m9PLfQ9ydfA21wJj0NaP+Zp/fg52R3AHaqzcGzhGJU0ABwmK98AYKRaDrwFeYGT1zV8h8DbSFkBBwCMlZVvADBCHQTegj/vWuGT/vsi/X0I0P11z88PnxsCb/+uhMfJCjgAYIwE3wBgZDoKvK0c//r589YVbrePjm6S/QIrq8DbfyjhcROAAwDG5pYsAIDx6DjwtnL3083NYkca36U/piU+bxV4Wyrhg6rLoR5fjvTwLuzSCwCHw8o3ABiJngTeguNtGy8EcVVT0XQKvB0oK+AAgLEQfAOAEehR4C04uX109PrXz583Bszis9+O0//8l5zPuUpf/4vA2+ESgAMAxkDwDQAGrmeBt5W81W//Pf3xb+HvtvzJ1aebm4v0M/6phA+bABwAMHSCbwAwYD0NvAVh9dv7sMpt0y9DUC38PvkagPvz2q+/BN6ULpn6IgAHAAyW4BsADFSPA28rJ79+/vx/bftl+rv/uH109P8l3wZUBN7YVl8E4ACAQRJ8A4ABGkDgLfjr7aOjf/z6+fN/2/YHawGVJ59ubv53pUvB+jI2AnAAMFK3ZAEADMtAAm8rYbOEsFvpPOeYJunfLJQuBc+BUP8vR3p4F+m5cKWUAWA8rHwDgAEZWOAtCM9z+5fbR0f/ZdfmCdt2RoUt9cUKOABgMATfAGAgBhh4W/lreO3a/RTKEoADAIZC8A0ABmDAgbeVk7znv0FZAnAAwBAIvgFAz40g8Lbyr4IJ1E0ADgDoOxsuAECPjSjwlnUvbwMG2ONcCeeJTRgAgN4RfAOAnjq6c2ea/ng3wkMrtAMq7HHOnCfjDcDdtSMwAAzTbVkAAP2UTrRn6Y+LER7acfp6d3TnzolSpuZz5mqk58yFwBsADJdnvgFAj434eVZ/Tl//lh7bf02P8T+UNDWfMyHA+y8jOSS3nALAwLntFAAGYMS307kFlabOmTfJ8IPWAm8AMAKCbwAwEAJwUOp8CavfPiZfb3MeIoE3ABgJz3wDgIEY8fOsPAOOJs6X5YDPF4E3ABgRz3wDgAHxDDgOXVjRltaT/zd93YTzIed8+ff070JQ938c0CEKvAHAyLjtFAAGyC2oHGi9/7JKMn2tVkmexl2Bd71nkv74kAzj9lOBNwAYIbedAsAAuQWVQ7Mh8Ba8yasr6bmySH+8GsAhCrwBwEhZ+QYAA2YFHAdSzzcF3lbmsa4sc97f580XBN4AYMSsfAOAAbMCjrHLCbwl8d8vc86TEJi76ukhCrwBwMhZ+QYAI2AFHCOt13mBt6yHaT253vFZk+Tr6rc+EXgDgANg5RsAjIAVcIxNycBbcBnfs+0cWaQ/rnt0iAJvAHAgBN8AYCQE4BiLPQJvq3ryIudvXvfkEAXeAOCAuO0UAEbGLagMvP7uE3jLurerjqSf/0vS7cYLAm8AcGCsfAOAkbECjqGqIfAW5K1+6/LWU4E3ADhAgm8AMEICcAxNTYG3YJpTP952dIgCbwBwoATfAGCkBOAYiliWdQTeVh7t+N2sg0MUeAOAA+aZbwAwcp4BR8/r5yrwVvdz2H5I68Zyy3eG75u2dIgCbwBw4Kx8A4CRswKOvmow8Bac7fjd+5YOUeANABB8A4BDIABH3zQceAse7PhdG6slBd4AgC/cdgoAB8QtqPSkHjYdeFvZeOtp+v2T9MfHBr9X4A0A+J2VbwBwQKyAo2stBt6C6ZbzYNHgdwq8AQDfEHwDgAMjAEdXWg68Bfd3/G7WwPcJvAEA3xF8A4ADJABH2zoIvAVt1gOBNwBgI8E3ADhQAnC0paPAW7CrDtS546nAGwCwleAbABwwATia1mHg7Us9SL+/6e8VeAMAdhJ8A4ADJwBHUzoOvK00Wf4CbwBALsE3AEAAjtr1JPDWJIE3AKAQwTcA4AsBOOqS5vV5IvAGAPCF4BsA8DsBOKqKgbfLpD+Bt2nNnyfwBgCUIvgGAHxDAI59ZQJvYyXwBgCUJvgGAHxHAI6yehx4W9b0OQJvAMBeBN8AgI0E4Ciq5yve5lv+/S8lPkPgDQDYm+AbALCVABx5BnyradGyF3gDACoRfAMAdhKAY5uBP+OtyIYQAm8AQGW3ZAEAUMSIH6Yfngl2+unmZq6Ux1cf0nK9tSX9v+W8VeANAKiFlW8AQCFWwLEyoEDsckv6pznvE3gDAGoj+AYAFCYAx8BWQG5bzbirnAXeAIBaCb4BAKUIwB2uAd56/H7Lv9/f8u8CbwBA7QTfAIDSBOAOz0Cf+TffcByhjM82/K3AGwDQCME3AGAvAnCHI82LEHQb4mYbsw3/JvAGALRK8A0A2JsA3PjFwNv5AJM+T+vnpg0XHqz9v8AbANAowTcAoBIBuPEacOAteL3heCbJtyvfBN4AgMYJvgEAlQnAjc/AA2/B9YZ/e5r5b4E3AKAVt2QBAFCXgT6Uv4hw++Lpp5ub+YGU49ADb7O0rE7XjmmS/vgY/1fgDQBojZVvAEBtrIAbvhEE3oLXG/5ttepN4A0AaJWVbwBA7ayAG2y5jSHwtkjL5+7acU3TH+8SgTcAoANWvgEAtbMCbnhGEngLXq8dVyizcGwCbwBAJ6x8AwAaYwXcYMppLIG3UC5303JZrh3be4E3AKArVr4BAI2xAq7/RhR4C56vBd7CcQm8AQCdsvINAGicFXC9LZcxBd6+edZbemxn6Y9jgTcAoGtWvgEAjbMCrl/Cc9BGFnhLNtSvpcAbANAHVr4BAK2xAq4XZfAlYJi+xrRpxHWa9w+dYQBAHwm+AQCtEoDrNO/HGHj7bpMFAIA+cdspANAqt6B2Y6SBt+ChwBsA0GeCbwBA6wTg2jXiwFvY3XTmjAIA+sxtpwBAZ9yC2koejzXw5jlvAMAgWPkGAHTGCrhmjTjwNh9pvQEARkjwDQDo1AEE4CYdpuFFMr7A2yL5uqrQc94AgEEQfAMAOjfyANybuAKtVel3hsDb+cjyMwTcbLAAAAzKn2QBANAHv37+PL99dPRz+p9nIzu0v4ZXenxv2/rCozt3Qh6+HFk+9uY5egAAZQi+AQC9MeIA3El6XH9Pj+/fm/6izHPe/jyi/BN4AwAGy22nAECvjPgW1MuWbj8Nu8cejyjfBN4AgEETfAMAemekAbgQEHvR5BfE203HtGpQ4A0AGDy3nQIAvTTSW1DD7afv02Nb1P3BcVXdm2Q8q94E3gCAUbDyDQDorZGugHva0Oc+Tl+TkeSRwBsAMBq3ZAEA0HdHd+6cJ1+fZTYWIbA0qzF/wmq3j8k4Vr0JvAEAo2LlGwDQeyNcAVf36rew6k3gDQCgh6x8AwAGY2Qr4O5+urlZ1JQvYdXbZOD5IfAGAIySlW8AwGCMbAXcozo+JO5wOhl4Xgi8AQCjJfgGAAzKiAJwde3i+tPA80HgDQAYNbedAgCDNJJbUCttvBA3WvhlwMcv8AYAjJ6VbwDAII1kBdyDiu8/G/jxC7wBAKMn+AYADNYIAnDTiu+/P+BjvxB4AwAOgdtOAYDBG/gtqD98urlZ7nncQ93l9CIGTgEARs/KNwBg8Aa+Am66z5uO7tyZJAJvAAC9J/gGAIzCgANwJ3u+bzLAYxV4AwAOjuAbADAaAw3A/bjn+6YDO06BNwDgIAm+AQCjMsAA3PGe7/vbgI5R4A0AOFiCbwDA6AwsADf2204F3gCAgyb4BgCM0oACcMcjLgaBNwDg4Am+AQCjNfBdUPOc9Dx9Am8AAIngGwAwciMOwPV5xZzAGwBAJPgGAIzeyFfA9Y3AGwBAhuAbAHAQBOBaIfAGALBG8A0AOBgCcI0SeAMA2EDwDQA4KCMKwM16lBaBNwCALQTfAICD07MA3HLg2SnwBgCwg+AbAHCQehSAm+/5vkUP0v5S4A0AYDfBNwDgYPUkALfY830/d5zuqzT/nqhFAAC7Cb4BAAetBwG4fYNo8w7THAJvNq4AAChA8A0AOHgdB+Bme76vq+CbwBsAQAm3ZAEAwFdHd+6cpz8u2/zOTzc3tyqk95f0x3GLyRV4AwAoyco3AICogxVwVVevzVpMq8AbAMAeBN8AADJaDsC97fj9RQm8AQDsSfANAGBNiwG464rvn7WQRoE3AIAKBN8AADZoIQC3SL9jXjGNi6TZAJzAGwBARYJvAABbNByAe1XT57xuKH0CbwAANbDbKQBAjoZ2Qf3h083Nsoa0hd1OPyb17noq8AYAUBMr3wAAcjSwAu6qjsBbTFv4nKua0ybwBgBQEyvfAAAKqnEF3N34vLa60jVJvq5+q0rgDQCgZn+SBQAAxfz6+fP89tHRz+l/nlX4mBDgel1zupZpusJtp/9SMV0CbwAANbPyDQCgpAor4MItovfqXPWWSVOVZ78JvAEANMTKNwCAkiqsgPtPn25urhtK0z/TNN2k//mvJd8q8AYA0CAr3wAA9lRyBdz8083NvRbS9CH9cVI0TenrtK7NHwAA+J7dTgEA9lRyF9S2VpcV/R6BNwCAFrjtFACggoK3oD5p6nbTDen5jzQ9/0h2334q8AYAAADAcIRbUNPXbxtelx2l53JLej7EzRkAAAAAYDg2BOA6C3SF743fL/AGAAAAwDhkAnCdB7rWAnACbwAAAAAM39GdO2d9CXSl6ThJX28E3gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgHrckgUAAMDK0Z075+mPB+nrOPPPbz/d3LyUOwBQnuAbAAAQgm4h2PYmfU23/Mk8fZ1+urlZyi0AKO62LAAAAFKXyfbAW3CSvt7JJgAo50+yAAAADtvRnTshsFbkttK/3j46+vnXz5/ncg0AirHyDQAAOCvxtw9kFwBDEx6vkL4u09eH9PUxfb1JX2etfLfsBwAASjiWBQAMSXyuaXh0wknmnyfp6yz93cWnm5urRr9fEQBA7wcLYZDwournpIOKU7kJAMABepx8G3jLepGOt6+b3FBI8A0A+i9cqZvKBqBBixJ/63lvAAzN/ZyxdgjMzZr6cs98AwAArtNX0Sv+r2QXABQn+AYAAAcu3mrzpMCfPk//diHHAKA4wTcAACCJD5u+SDavgPsSnEv/5pmcAoByPPMNAAD4IgTgwkOn0/88S77uAhcs0lejD6IGgDETfAMAAH4Xg2xXcgIA6uG2UwAAAABoiOAbAAAAADRE8A0AAAAAGiL4BgAAAAANEXwDAAAAgIYIvgEAAABAQwTfAAAAAKAhgm8AAAAA0JAjWQAA0MKg686d4/THSXwdb/mzZfqap6/Fp5ubxUjzYZrJg7+lr8na8f89/vcqH+ZqT6m8XR5ynqV5sDrHJhvqVzinfo4/513lU5rGSUzXrrYgmB1SeWbayGn8p23lt8qbMbeTk8yxn2TaxKSL445ty8o0lsUqDeFcWo64DIr02WPNg/Vxy64+e9TnZB1uyQIAGMSE+l3Vz0kHRPr99getZ+nrfpysTEp+xDIOZt+mr+uuBvbpcYRjeJFJfxhYP0/Tc1ViAhM+46fMJLKX+RDT+jR9ne9zrB3WtWfpj0eZCWJI90Wa7lmFNudFprzC571KP+9lg+n/aa2OFf6+WEcfxHp2XOKrw/e8Tr/nWQuT+GxbcLzHx4SyfB/PgXmP6t7jWPcm+9S9GCz9KebLvu3DdSZvlh3nx3StLr8tUo/X6shZiXZxddyLGo9hn76rF/1VTcf9YM/zdLHKg/T4rzs8jk199pOiaarpnOxlXUiP7V3yR3B/k9N9+80ibg3gBMgW+KgiqWtXNJJMRcgW+Cij6PS+bmav8Kz+e1Uvl1Yh7NWOtdJ+rZXdNPnjipyyG3D970PwbS1fkiYHJyOoQ6vJ13nNH30VAxLzFo8lDOLfbPn1w12D+ZgPT3MGuvu4jvkwq/lYw5jsw5YJ12lf63ya7lDPLrf8+l7Z+pLT3jypOwAXgzcvtvz6YlfgMx7706R8YHvdPJbxssbjWk3kH+05gc2b5L9OXy+7nCfklN3OcyaWXd15swrEPe9izrjjXAzzuXs7zrdHSbGAW6PtYubiQ9kgdq/KYc8+u44y6DwPcvqDLs7JTsYuO46xv8G3WBGrDpgWRa4WrkX7T3I60d+Xd6av911Glks2ZtPM8ZWt1LPV8Yb/bqKjjVcdK59cVRuYeOJPakjLouqV6lhu513nSUvBhtWKhKLn/DzWy0LnYE3lOivTINZUfkmZK+Jxorq6Upg9z583cWV9x/cVKbvXRTrCmtqGsmVXR/9TqOxi/c/mY+31v6aBYSvBtzhhzPZX0wJ5ke2fej/QbrgtfZHUH2zaNCa4aCmg/2FH2xL62btb6uvTlvLheV0D5TTdlzv6jFC3T3ta7z7u6F/DqoOHJT/vzY5JaLgA8UOL6d8YtIh17LKm8WJ2vHZRw/GENnS1Guy4hSpwlXQXbPplxzFurHsbVuWMIl9iuX/ckR/fBJLjGPVFzQGf1XE/KTNXjGl/kdR/waix8W+NY6s2+qrW6mLPz8lGxy4bVoC35Tqec7nHdavAATytYcJ1mjMhrxph7WV0PTZk58n+t1nkFfLbOm+DyBn8tNbA5jQatU80c9Ky64peobpZ9yC15vr5OPl2aXyVc/BVsuMKbIErDbXXr7YCFgWvFNY2+MgEFesou0Usu6sdZfdb24OvmvqfnWVX44qJZfLHVb2mBhSN1+Uar/yGwdXrvt+m10B7+jS2qW163sLtcr8VrVMd5sPLmBfLisfa6RXxPdMc2rHLfcfhe7b59+pcwdCjOlY5wBonsZcdTP6WsQ961mLdy+uXvhkDx7HLZQuBjk6CPzmrhL8JfLRQT5YxyHHdkzo7j+npxd0XsR25TOoPfOaVyfOmbt2PxxXiDR9Ktqdt50Mj52Rd84aK86l7eeOQ2x1W+vMY7AkFXjUwtQpyfQxXLWPj3uUJPYlXTz8m3z4vo05fGsoQqAqVLZ48lQcdNXzGjzUEFY5rLItpl8dTU57W3uHEBupjTYGH1Tn4NJ6Dz5IDEfPyRczL86YH2w2V3SS2Ux/jJO4Qyu0s0//UVf8fZ/qg44HlxzQGHd7VNACbxv7pYw1t8BDybzXYfdzB1z8NK9O6Hvf0IB/Cd36IaWjSox5WwZ8KTPjqdtxRHTuO7dTjHrYDx7EdfdNR/hxn2oOTnmTLcbbfje1DF33CKl+aLpeTIvkRx41N15Pw2W/yxnVxvtpGnQ15864PdTOOSz4m7QecvqwuDCuLG6yLxwPIh6bGLl33z5MieXm7gwp/Em9hqHup+Mp5HIA97uDYshPjxifiG4IeVY/5bQsdT5FJW52mNZxIVbzv2yQ7Dn6eNlQ/+zj4a7rzftzS950lfwTdmmpLQsDk3dCCRyXb6DdxoNlUsOI8tsdnA8mPF3Ey28SEaBIH229GXKfOY/5NOkzGSdJO4Cmvfeo6H1b1rUpdfp3z+7M+BDrX+qG84307knNtFXhrsp6/3TNtJ7F/nvYgq1ZBjvOetZNdBSWz+fKx67FpDHa1OUe93HZRPOc2+6bGme867qsex3aky7p41oN8OO9BPtQ9dunDODN3fHC75YI+a6HjXGX+izZXIKwFNbqwOuZ3FQaGszoqXcU8v19zvlRduVZ1INWb5xHGzretyVFvrnA1nJdttS9tXCXN1vmPYyu72C7WtbKrSHv8ps+r4GL5trWC5GyM7UHmdr99y3gR+93sazG0SU1PJtbr+bDXeR5vlc4rg6c9qoZ5V/oXY7j9u6XA29U+t4PF+v+hhvq/rKEdyJ4Hl324E6HAbdFdtA9d9UVhfHXewfc+XQ/GdhB460NfFY65yqOE6uyzT5Ju++wxnpN92KAytz4cjbygw3eGlXanDW9LX/W5YHU37CGKfFH2IeAhj9L3zWsY3Jwk+wfypg3kR5XJaaUTsC/PIOyokz2OdfF0TLsitpmXLU04dnWGp2PYHTVnB8PB90F7tm1tX/E8GVmd2mdME447rKya57WJsYxC/1XmmbFdnbdl8mEVYHgf8+O73YPjxczVLtFlNkH5Jk3p5yz2zIfnOccUHpvS+TOGMxuV5R3LGBR9hMvqGdB/j/VrvqntzexC/vu5uU8bXWFus4jpfB+/e7FjDLBqCx7sMRYIQZe/1bGJREvtwyq4sSq/b8bRmfxY/dwnT1bt5N0+9csbrNrJJDOnWrWF+7SLoU0MdW0eL+iWGccuM+Wy2vRwVQZ/Scpt+LUqg8s2x0Z7jt3DMYfVsLO8viSzCrlMneyqLlY5J7/ps2s+J+9V7Fevkm4fSbDqf3bXxR4PUusc8Icrsqc9OpnbmDi/iQG4q5LvfZvUc+vobI+8DOme1J0XYRKz5wC8aj7M+lAZcnaqa0Ooi73cIa7P53uHgbfvBgUDL7PjpNtVOdmg07IH+dFF4G1ok568PDwrOaYJ/XCpYE3ss8LrZWZDl/OCefwmDmL7lMchD94WuSiYCUxeZ87hkOdlNueqUteuY7Bn1zkSyuJZx3matwJvOaJNT/Lqfqgzr4pedI51YlaxHdhnbnMV0zkvmc7wepbZbKnMbn4hWPxzX3ebLJMva+V2ncmTVfswKdM+pK97PcuH0EeEgPn1lnZrtja2OUvKPf83BLyelwhQ5J1X15n0lK2bJzHtT1qKQ5QZu79MSm6gFfut1Xm6OrazonWxbxdpK56Tx5m6UOacfFMlH9L3PUnfv+ov2h7jhjwotMNwG7edTpLuV4VNY5R/sBPxPV3u8cyHWQ3fu++tntOmyr/l41jp/DkrsY52favXcdKf5c1V8vJZy+f7u56U3ZuBF10fzoFVAO64J/lx3HGdejfgdmBSoj0Lg9YQBLuocjU3vDeuXLkXP7PIuKsv520YjN+NeXC95/F/CSKlr3D8D5Pit/ns1ffEwfOrnD971OX5nJnc7PIqGb9wPoTJ2um+9WvP/D8pObfJngfzim1BGIvcTcqtanza0w2VrqrmS8yTl+kr5EkI5BSduJ/0aIOwZZy4341t3bLAca+C6/dK1IWTgn3Doux5lamb90rMJR83fdtl/PzLkufpk4p99jzuantasL9aBevGck4uM+fkRZlzsmo+xLL7Iezouu1VoH6e7nr/llfhOw7aCr71YcLxuM5d1wYQePt9olWmw42R+6qR930b0vsN5cH9lo9jZdZlwXcQLMrLy2kyUHGly9MWv68PAaOVwZZbdNajc+CyJ+noPA0D3hW56CrKsNLtXp23f8YB/b04OM49b7vYeGptMvkwTEDqvD0zTgSL5sGX83/P57+9zBkLrXY47mxMWyD/XybjtjrHWh1rlVxN3dR5sMwE4Yq2MS969NzNRZzgXtScLy9jnhStE097kCerizQvK9aFum4tvo7pme2ZnhCEOy3RRr9o4Vwt4kkD5+ks9ldFApiPO94dvqlz8iqek0UvjnSdD427nRyWy5pO5sfJMAJvvx93yc6l6kBm300XmjrZ9u1Yq6Rn3uXy4dhwPU3oVdtRsOzOB9a+UNxZxwGRPnnap10jC56bzwr2JxdN3uIVV8FdFMzjLi5+rlYjXTd0/MsSebDX5K7g6refOqqHoUzzNlq4GvKt3V2fYwXGA5OC58G9JlfkxUBH0WB0X+5CWOXLrMH2oRfBnxJt5aKG475KqgfgrmIAallDei6S4heKmhoLFLkldxUgf9lgfXxYMC8uR3xOPixxTo56/npowbdJ1avteyw174sytzy9r+H7Tlp6T9Fyn+xRzlXMuiroWM6XCXVqa1fTyUDbF0oMBocWdGoyL4aS0IIBj1VQ4Krp9MTvyJssHHeQx6vJ5LylPCgy2ZzsecvdVUOfW9VZgT5pzLecXnT1LLt4YfOsxHmwaCNdJQIdXa86XuXLskd5Mu1opc2i7ryI58W+m6zM696YI35ekfnQ0wbO1TCPK3Kx82Ebt6wXrI+TDs5P52TLDi34FlS9UjnU5x8dl5jU19EIlTppWjjJyn5+1eBbl897K/PwVfol7yHfDJ/g+B/OBxSILHJuPm8zKBCebVKgv37cYh6HwftFmyuuCgYh95rcxcDJVd2fW1Mfv8tVX3Zab8DzjjeRKNJ2tzaZ3XNi+6ijdrf1fIl5ct1E+1CDRtrKuCK07MWPL6u/mjrOJP9xRk08HuRFwTKYtVwf5wXOz7bmAQvnZPsOMfi295XKGI0eclDjvEiQKw7aqg7cym5WMG342O83nP71PJx1UcBxQOW2tgEqcUWd4ZuO/ZkWJTwawLlZ5OH2s45ugysysTlvKy1trHjb0N8+KTChmez57LfnDX3uvnXxvMA49PlI24pFlzt2Fsz7ZdJB4G1tYps3/uxiReyqfegiX4q0kdOWA5JXDc8Tyu4g+qqpgH383LyVuMc1P5e9yHOmrzoK5D9M8p8neuacbP2cbM0hBt+CB3sOvpuaJMxjZxkGTFfxvxcNfVfRDrdqp1B25dj9hst82nD6s647rNue8zZcyk55H6LzAaSxyMPtL7pIWBw450202ghwztrcbXLPyeaDPfJ3keSvJmozgPyoQDksRtpWdB1ULNJmP+zBs/byJvdf2t2WJ7YvuwjMZ9rIInXnbCx1OQb2iuZ3G5uzXBX4m2mN3/eowDE/6ag+hvb5VcX011ImXS0UKThuabtvbU0fgm+z2AhlXy+TZp+ZdbbHks4w+K5zGegiDtZ/iLs1hStlz+IuI6dxe957Sf6OW2UVXXFR9blvZTddmDZcz8o+961Ket53cSIVXJ1Rh2U8P2dJc0HigxLr5rTlslvK+U7zpo+r3+axz1nvk5vsj48HsAow73EVr7oMeMSr94ucPG56YtlpYCROIvLq6b558KoP53L8jpM+l0ODFl3ebhrPn7wxZGeT2Q0T2yL14LzFZL3qOE9eFhivtrWBynVL/cXrEulZNpz/4XjzLs7cr+lcLTIXetJxkDxvbn/SQnC86z77qsA52fex4V66Cr6tOoYfMkGn7OtJ3Knmbvy7Jk6QackTuc7oazi+u6Hi7Tr5w1WieDtFmS16iyhyLHV830nB/G1rm++20tPV4KvJgVQ4plWweHXeroLEPyRfr7R2NjAegSav7lzF8lkvux9i2V0k3a7W7NJ1Tt40Xa9/6kEerPrju/FC0JMNffJppq502h93MOk+yZl0t7FqoI6B9IMGv3vRh6BDgcnm8T79e1yxk3d8bVyhz1t5NetJOTTVVncpr63ubCXNljp7iMGmqnXopKVnbb3t2TnTVnryFibUNQ7Iu8iy6Pi5kUV30z47gHPyVU/OyVZ1EXybxUH+s7yoc9xC+1nydQVY3cuV75c8keso/NWzIF6WPUlLbtGbezx5EfVYNlXzfFrz37VV5lWCb4uultY3NPgP5+tqZebGYHGsn9fxWSN1B4oPxXmDbe1FLJ9tZXcV25d7SYe79HbQD4V6/TAnb5qu12cdDyxWD8B+ljcQW9WVhvLifo/rSt4E9boHt5mtJlrLjvrZXrT5BSdU++bD8wLn8qSpYyu4OnrMO5y+7+qLYxudNxF+1ZN2oEydnbS06vhtT/KjyEqwNhYDtDLOin36si/pKfI9NY2H8i409aWdvKp4HINsT/cYO0yTkWk7+HYdJ/GlOqjYgJwm9QbgTmo8kYt6UuWqZIkdQgpN+lpokItuWtDWxKvoCVxlAN1J8KLA6ox9vIzn67zMuRoDOb25Atx38XaWugMwT2LZLUqU3TyucHo58izvU70+7nBgsQq8lepXG7gY1PfB1SACHnFcdZ0z0Z409PXve1ReeX3wj3vm76zAZzf5HMe8z150/My9NtqrvrYBRSbSXbQJIU15Y4AHPTgn28qPedKD29xaXnGUd94s2goaFxxrnLRwvvblYtEip3ymB3BOLgqckyfJyLQZfAuZe1GhgFbbINfVSBSq1AWveBVR164qdd32U6TDrXq1alJnWdSg6PLVKsHAriYhdefh83jL877n68ukoweQdzQpCMcb8ut0x+uqgfq2sY0ou7p2reyeJOMNnj7pYb1+0EE+fOlPKw66i+wwWVgfd7WK/cVJzsRl3qMk5/U/Jw3Wp6HkQZV6lhdobeQh9vEzz/P67DF3sh3fIpXXR1/3eJOLvEDDdORlt2m8tsvfGv7+Wc+Ot+2yabSviAsRds3z5j2rj29zjmfa0DnZp3FL3jnxYzIybQbfKj/cMJ4wbQ8w6qr4z2s6YZZJPVfYpgW+q2onkTvQj4PK456V5xB3Oq1zAn8db/euWldDPR3rKqpNz8kKK6pmO16LFga/L+sI8scg09hWUVxVCUqu1es6+6FpB3lReYOAErtVFTXpYZ3J6wtmPUvvrOLx7FsX+pQP86byIK4syztvzhs4przP7PwZRiOX10a/7XHa8261HOUzlXb4+wD7oSr+0bP0NB30ORnYuTo7sPq4yc85v/fMtz3VuRz+Kqkpcl4wolzHqpSrmiPtr1s8/uuGv6PtiedJTnonFU70eYfP/KhrUhXSX9vKnrjKaJGMSxg83C3ynKyWyy6kpc6gUFMP1+9CrYGiGJyuaxA56WDV18ua8mFWYz70cYCV1z/16XbLIitMRncFecu53mQ9y2tjH9UZzCi44dfrhC7HV7O+JrzFW/2GNH5jvCYDO1fnFY9nDGaHlgdtBd9qGxgUeK5J251uEbVG2mtcLlrk2N43/B37Bjev9nzf/QbLu5NGvebVg008NHhMt8PM4kq3Ni8AFM7nOsuu4G5MQ9HEtvJDXfVV9wYBdfXvQ5wALgY2kD2EFS6NTq4LPEcr5PHjGr/ycU659WW33VEqsDvusse3nBYdmx5S8G0pL0Ytb47Xq+BrHIvtqpN/U6TjC74d9aThLysEhM5bSvu0h8e/GvRXrZB/ayHtPzaQv7MKdSDv+04q1suhN0y1D+LDZCUdwD4dQQO6eu5knWpb9dbQbUehPjwa+KS9kQs2YdVXWq8XNdXradJe8L7udmqWjFfeQP5dWgcMjXs2mWmhTMIFpcsdvw875D6r6bvydtvt4y6bY5LX9w1hJdU8Z+x7rJjlxYH4ZWB99kSRjU8rK98aeB5IK51djbcChZP9tzpfNZ2QJwXKrsjuQHt9R7ydYp/jeF+lDuSsNrpfoZ539YysaU2fc93gIH4Mzw9rYvXUcZ/zt4OVxo3UvQHU67+0PBGrs464jWc4rOqop85fJbtXK4Rbyc9rGIOeFxgjWfXWrLw+ejGAY8h77tdfFDP6OGjH7SEmusXB/kQV+WLWUEM43Tc9sQ7sO6GeNtBwz0ZQzu8H+tltaCoI9aOyG3S9ruuRAm0OGJvoPxcJYwgkUFzeLflPa/iOvM+4suqt88n8zwM4hkXFYwR9HNSkjeDbTDb31qSNyeuOlWZ7rTLLrKTct27d35LOSYWGu8sddOp6JsBcO7A9/Q1Nco4HUHaLgZddY3nTs10ei6Z5qY4cLIGa+rxM8le/nVUcN+WN0Z4rBrTPAMNxWxbsNHF8X1Rd8bPtqtp0j8/KTnb3DQpOS6azbLoGWU+bDCSM4Or83/ucuCYf+DzEANNa+t0WCd33U6NScEOaRxW+osiqt4WSABgtbfwICb7tNpEFvw8yq0xgt91at0+w630dE4ktO1jtG3xbmuCPvhMxaUXdYMhCP26lVL3ynrc23WdH6zg+yXvfa9mPuQzosxmWI1lAiQnmvsGpkw2Dy2mFdHwRAl7p54TGaZ9b98L3rwfM9t1s4Vr1KGRhENgIgV/orl8cStv73EqpesWdVa+S3TuvP9qjnuStmJsNfUXywMYtuwxhs4JJxWOEodg1J6y6kKTtcf1zz/QcJ8E3jVRR4Zlmj/f8nk1Bu+meg93ZhsnPPs9VCYG2lwXSWcR7VamWAWDfO8K+8rDkbnnA74FK+6NTuXDwwsqE8x2/PwvPky0a+IzPnj0v8J20I6/cxtD//qyYGYn5jvnlUp9NH7jttFqnO4ZGqugkY1blizasdNtnldmmNNTy3LeKmy3MxlAZ0jxoOogwGfAk29Unxjz5YrP3OW2msj9wMah2lfNnZXY+zVv1NrfqrVeGMK65r5jAnTf0g+DbbgtZ8I0qt1euT1KmNU2E9h2EHq9NnPZtlBc9uJWnrlVZjU0kWwjsHbQYPG7qs6cDzxv1mn3lBd0N5gnyVqKdF2mjY3tynvNnr2R3ewoEOidN9r8tje1mSpqRyLtgNpVFdD4vkQWt6GvHVjZoExq1sz2/68caJsOzDQOj8Ny3fY9/msmDfRvkPjzv7R81DtCaqqs6vM0WNebvVUNpHHqA4SRp7rZh9Xrc8urN/cQzPw9euACXjkNmOe3Befp6lvNR4dEeuwL64WLflRzvpB046aj/rTbJ+zrePi5wfHAIY+om5zlQrF2WBc13SCO6x7xKg3VSdcK64wrkbM/P/HHLf5fRh+e91XVL5Kbn4CU1fjbf+7nG/G1q8P9g4HncZN7UVa89N3KYY4BwMeqJbCL5uvpt1zjk0dGdOy9zHmHwqMB30E07cJLTR171NO0/5fx+4bEaHFCf/VOD8xwoxG2nO9TVIQ1gSXrR/AiN2mLPt59UnLDOGpi4Trekr6509aWzKeqswbp6lrBx4Ftj2dV+C2T8zKGX3VmDt4ee1/Q5Jj/9HQPsal8nbmMh1pVZznggtEGPd7S158nuFUqhLlpl2Y28MeZZjx9BkNd/zxQvI2qH5znjqZOxzMkZLsG3fHV0TFP58c299vvkx/sG0vTlWR1x0LRPYzzryRXDOm8ZOK87cXFSobPbbFHT5+yc2FXweAR53EgAscBkuatzmHq9zfn9T7KI6HmFupK3KcMrK5Q6UyTo2bu+Mu2jzgqMvd4qXg7sfD2XReTFB5r8cMG3diZFD0aUH1VujzqpsKvobNsvKu78NU32X/XWi1vF4oB8UdPHParzqlAMbD5NaKLubiq745rL7tFIsvpFA3lTZ70WfBvwQN6VdDLt+a6+eBKD9uvtSV6QJPTxbpXqdoyV1w486uHqt7z+e5kem9WUjM3bAZ6r9EujYzrPfMsXAixVr2h9uZ2vjl0xa7zFZd9dOkNHfbnnd/6Y7Hl7VYEgRfj9Pnlzv8JJ1qdBy7ymxuI4lm9dzyl8mlj1ljRUd7eV3cOa0nWZ1Leyq2t1582LGuv13IqWXk+8w6Y+ec98elFj3WLYnueMkUKfeLU+Gcz5zCttRC8m9Gc5fUwo2148AzIGefPGFQJvjLHPvk7r/3LH+HV1p8gzuXWwFjm//7HJL7fyrdjEuK7JWtXONHSk72p6ne/ZqOU9A2eXMHm531AZvK+Qpn1OsmV8tkCfBoZ1maZ17bKG+nqejOO2xabVuYLyrKaye5aM7zl9Z/G4qubN46Te2xZmToHee1Wgbk1lE3E30l0D+0lc6ZYd100r1j/aKde8AOjjuLtop+KqniJzDvWKQ+2zn/bhXKUzeZvdNTqeE3zL73Dresjt2abbDRroTIuqckz7ThZPkvqf91ZHmk5azIOm1J2ecCvV5b5Ls2OA4lIL0vi5uLXsKrQ1oZ0Z663CT+PxVcmbFzWnyU6n45h4v3ErC1Hes9+yK93ynhl4VcddE7Qyoe9LO1Bk1fqsZxeQoU5XRc4TffbBypszH1eJ2eQRfCumrlVFl9krniWFCV9dUfpFxU63Sn5MGjhJqj47a9JhnahrchgG53UPpELD867Mio64gcW7pP4AxZgn9lV2Ed5admk5fChZdmHF44dk/KsVH++RNyexXtedN565Mxx5AZXj2F4azGvTw8RvV7B2GtvbSZK/iva5HO2NlwX66lCmb7pKYIlV608UJyNugxcF2s4wp7ZI4DDrR5GYQWPPvBZ8q2cgVcabMrc+xWDGh6Te25xet1Bp2z5JgjbTNethVW3iFoKTOKEMr40PFg+TzRBUTl9hwPkxGdfuvm153ULZHW8pu/MYWHqX1Bfg77uyefOhoXp9peoPZhxQZOK9qledBOAyAR363x+HgX3eCuOZVW+9agOWSbFgaC2P7tjj/D9Piq1av7LqjQPwssDc/ayLc3Wtz3bBrht5F75P4l1ctRN86yawEW59+hiCcNvuOY8n5GUMZtQ5Ia5r16y2VmvMSvxtW4OJRU8HxNdJfUHi7waTydcrRKHe/haDFuH1S/pv4RUCb2eaib1dNfjZq7L7JZRXpux+i2V3mRxuwLTrvPHMnWG5KPA3rQfg4lgi1Nd3sY1+53k2vZ/4nRXoM61665l4Mb7IuHS1+vy4pTbgRVJsFU+ok1a9cQjn6rJgn13pMTt7nKvH8ft+i332auwpCNeuInewvWhiLCX4Vt9AqqxJ8vUK1YcYzPgQT76PmRPyvInJXk27ZrX1nKL3PUzTrI8VNJZrW5P5aXzpLOopu0XSziqo40zZ0W3eXFvVMrjzdJYUu3h1Evv2RutSZmX807W2OHyvZ9D1vz/eVT6ztu8yoLCHBecDjbcDcSJf5pEID+2cywG1w2FRQpHFImG+3fhFq/j5m+b3X/psJdZq3QhzriJj8Hd1t+GCb+UGUk1ehVxtRjBp8DvqWvX2ZWDYUtbPepimtz2uqnUHiWmPVQ7Km/6PBcKqkSKrrCdx0Pai7iBYnHA/S77eDn2y4/utRh5uf/xa9vV6PvCw4J+v2oHLBtqBEHAr86iP5wK6HKCw+m1RcB7+Ia4k76LPnto1vZfj8NXzfGurF4Jv5Trcl0l7tzY2UsnquuLV0EPiN33PrMTfLlsqn1mP62ibq9+ot+wWSX3BcfrNM3eG7bRE//dlghwHbpOKA/hJHMCHCff6ardtE3+67Y/3eUTHIl6Vp79lO0uK3dK2ch7bgRdV2oHMs0hDG/AiKX73Qehznik5DrQdLrpaNUn+uCutcrAlbtb1ItNn5/G4iHbrxlWJuMHTTBt+VqVuCL6Vd5EMc2XRdQwe1mnWcJpnPUzTvO9L9uMAy8R+mJ4nVi6OnWfuHN5g/jgzcAu3gz4uentLfP7rs3h7adGg28pCafWiTW/jPXQzcSsTgAvn7SoYv5rcTwtO4M/jplarZ5FOSnxvCLxdKDEO+FwNc6LTEn32JPa1v8Q++7xkn/0i9tkf4jlftM+eKa3WlYnrrNrwN7Fu/Lbh9SbvAsuRPC9/AqeZ+iQZ1vbEi5IDhKLCM9bOG0z3+z3f87jBNL0dUGPywRk7vEl92r6ESf07uTHejt4zd0YzFjiNg7AyE+HfH7Sfvj/8mG8Z+IVBXpWr4HOrp3pRTxZpOV+VGCtZ9Tas8r2K53HZOcFJfD2N799058Ykqb56VeANvu2z3yXlnlddtM+uer7O3BHRWb2oM64T6koIwN7dNta38m3PzjYZzu1hX67QNzTZa3rH01lL7+nT59fWmCTNBFxpvuxmidtPx+plfAAwIxm0pT/uJdVWGq+e97r+qhJ4C23IqRLqjTIr2TzrbZhzgjIrYTc53tAGTKrWO4E3+K7PPm2oz65yvq7aELprw+tccR7a8/NtvxR827+gniTt7E5YRRgInDYVSW/6GWv7PBi24TQth/Sw2tiY9KWOzhLLqYfavgy93PqS/lksV8Z1roZ+4V7Sj1sFv9zSnKbn1OrKXtWRRVLsYmWdm2LRbhmH8q0aiK977P9MycB35+oqAHfVk3M1LJBxR0T39SK0l3VerHiw7ReCb9UK6qLHA6VGA28tTGyrfO58YMfadB3tuoMJEw9XdPYru7myq+xhD/Jx7hw4iIHbaYd1LbTz9xp4tiv1KLIR0qsBTcBMFL9vAxYxEP+kw/wJ5/9du5rCznN1GcfYZTZPaqLPvtvA3RBDa5uXPaoXV0n1Vcy5BN+qF1ToZPu2CcM8DsLbmAS87eHnvm8oTe8HWke7DMA1edvzIbQv95Rd9UFWG53pDmFgZSXSYZyvs3jOXrQ4oL+K9esirrBqwmJgA/3epTcGQ2YFyrIvdqV12cD4crHn7/rYDnwJgCXtXpy/jhP5Jy33NfMK9air83CZk49NnTdd1OVFxfJrYlzZtz47nKttbnZ2Fc/VRla7xbZ52aMyH1R6YzD0bg1twdaYgeBbPQX1ZfDbkwodnil0r8FB+KaOrO2BX5PvHcwgomQ5XSTtPwNunrSz+nLs7ctF0v4tbaMqu9ge3u2gjQ7tseDzAY4J4oD+oqF+YxHbhNUAvum+adft0q96WARP9vxdp+lqa9xW0POWy/z1nr/raxuwjBfnf4h52UTZLjMT+Ydd1J/Yt70cWPvwqsH05gUS2q7L1znpaXsTuV3H39mjfcLK9fT1Q+yzmxgnLmL7/0PDF8qK1OPnAzsnn3dQH0JdDBft9709eWe7KPhWX0HNM8996WKiNYuT5S4GlrUvma0y6Y+NWt0N22LogYgYJG7rmSSr1T4CbzUNDJL2lsePsuziJOE0aWc1wqLD9pgetbnh+WvJ18DvkwITobxJXRhfhItrd+NkYdHScVwn36/wD//9vI/PldqR3idd7iSaedbQYkO6XvYsD8OY8uGGtDZS5vEznw+ljpWcxD2Lwfh7sf+p0rcu4mQwBNvamsjnHeOTLWV30ccNhrbUtUXM01lN44xN7fzLtoNLOem56CA911uCKat09qHPvpfps6vkzyx+xqrPftnWhdgd7ekQz8nrDtM1iwsgVoHZ6wLzsOtY5lvL+taudx/duRMy42nFtM/i4LNWadp+q+FjTptoeNK0hV0uHqevR0m57Yz3HZC/6nJAmR5vONYXdU7+Y8S5SprClsHnNaZpVNu1xzJ72kD9XMSJxPWG7wzbe08rfn6pgXj6neH73tXQAN/qSbk12bbsKrs62tuyZVdH/7Ox7GK9CG3EpOY8DJ3tqzjIXtZc9r2ty12c2wNvfyex7q3y7C/Jt7ubhn79H/GcXPTp+U0x7cdDCc73Nb1Dyse205p+30lsq+YjbwemsR1Y9UM/rvXr7zP9SsiLed9XUceyW/ZsFWfr6Y1jtWls15dxXrPo8DhDes5iXetDeiYxPcexn7vuc92O9WSS6af/tjZ+fJ8ZR/etzx5UezqUNiSeUydr4+tC5X6UULvYgIRJxLO0cM6TrztenNU8wQsT5Nc9OcHrTsP7mj7jvGdp6lMdfZnWzatYL5/WEIRYxMnzlRag+bYlLbtw9TwE4X6qoew6D+B3kI+hzbob2+dH6x3onvU/3E7x0i2mFKh/i1hnZgNNu/QeUD62ndZDWTE/xk0RhlZ2TaU3jgOuk/rvDKqSnqse5XtoU14OrJ7M+1KezsnenFN7teF5wbc6OoamOu3nPU5btnBCY3eVuQpyP070piU+ZnXVKwSAZn3rsMOJkh5fnfdk19G4zZJ67xMfXINbojO+ilcazmL9nJbI41Anr3vcWC6Sfj7foI6ye5Z8DcSFsvupZLtStuye13RO9i0fV/V/Euv/g5J5GPLudUv1v891+XVS/QLF6CaiAACwcksWdGfTksUNk0MTErqom5Nk+4qqxT5XwtPP/JhUX6V1MLemVSi70KYc11l2HR1HKOdGbjutWP+XnmUIAACUmmPIgu5UWbIIDdfNRVL/ytCJnG2l7ASG+ln/AQCAA2W3U6BxcZUnAAAAHBzBN6ANJzV9zkxWAgAAMCSCb0AbHsgCAAAADpFnvsFYTuZ6HlAfdr982EDyzur4EBuQAAAAMDRWvgFZZ3U/ny39vGlSz2YLC8UDAADA0Ai+wXjMavqcy5rTddmz4wMAAIDWCL7BeMxr+pyw+u28jg9KPycE3iY1peu9IgYAAGBoBN9gJD7d3CyT+gJwl0d37jyu8gEx8HZe4yFeK2UAAACGRvANxuV1jZ/14ujOnXfxmW2Fhb9PXx+SmgNvMbgIAAAAg2K3UxiXsDrsRY2fNw2vozt3woq6t8nX564tPt3cLH5vRL5u0HASXz/Fn3V7q2gBAAAYoluyAMYlrFZLvgbNxmL56ebmByV7cPX4WfrjadXPSeuOfg5gmP3AJPn63Ni51e975d800xfO5AhAx+2yLIDReZ6MK/j2SpHS0cQlrOIsspI0TArDhiDX2VWhALEtCSvEw3NQw88naTsxlytb82qSfL3wchbza/XvoW19nubdlVzamnchz36KY8Djtd+t+qpwh8TbNB89RxdtsjaZllkRAOPsVMay+i0MFO+64n2QdfhZ0vHKtz3T8DJOENVZYNWWhP74Xfzf0D48kysb8+kk5tPxjj8Lk+RTbew3+RaCbuFC0aTE2xbp68KKOLTJh9Umx8BjOPaTOM86FXxsjw0XYJwuxnIcBtgMTNgl+F0c3ABQbEI4Sb4NvC3S15P09TD5elFjNRYIE8ZLOfZ1Ep2+3qT/GV6TtV+HyfQs81qfXE9iXyUvod3z9iSct+Hc62iseJb88Xzu8P2PlEp7BN9ghOKtb08GfhjXbougR8KV0Vvrr/Tf7yZfg92zzN+uVm8AUMyj5I/A21XavoZV7y/DOCB9PYlt7WI1eYyr5A55Ar9avXKW+ecQoAyPHgl5dy99nWZe99J//yH2V4vMe87Tz3qs+kFrzuLrPGlmk7o8FjV0SPANRioMWsMAdqDJXybjWb3HuM+zsPtvmCieJt8GvMOVzXM5BFDINNP/P9nQ1q4CS9kJ7EFau21sJYz5QtDt2bZnj4Y8jP3V3fj3KwvVDw5m3HqdmR/OkuEv1hgUwTcYt9CgDu0+/tXzB1yZYWgDmpdrk8OncgWgkFUgadfOplbDf3WZfBt4C4/oeFJm3BRXE4bVcPfcZQAHN169iHdwmG+1TPANxt24fglkJcMJwHnwJ0OXfTbR5NBvjQIoaLFqN3f8zeTQMylurpBd9Xex7w6wYaxlvAXQHsE3GLlMAK7vVzYF3hjL+XZtsghQyqrvn8SdCDfJBp0WB5pPLzL/fbVv4A2A9h3JAjiYgMDD+FDdFz0ddF8IvDESP2f+O6x8ay3wHVfahQnq/Q3n2Nv0HJt1NuD4upvh+Ya0hUn0++TrJivLDtMX8u1B8n3A9G1MW6eT/b7mX6xz4Rbrv4fnTcV/O45pfbCel/H27LbS9VPy/QOtw7nwug/9TQwy/ZRs3qmy0/O1A6+SP4JrYRfAe9n6HOvUale+ZXKAt6DGNmqSyYMnAz2O40w/tV73Q1t21VV7m6YttGF/C3m7qn99P0/71Ddk+oPXZW9nzrz3fVv9xKGqUk4V269wHj1f9b87+ulFPLeue5Jfk0ybld2hdpk5xxZqFrCxwU1fYXv533ryetHRVtv0u54+q6N+1ZiGZyXe9yLzvvO2BgYFz+sPbd8KG87v9HVZIG2/dLHrXhgQpq+PBdJ32UVbVaJsfylTT2tMXzZtXzYaiWnZls5pT/q4d22dC+GYs21JH9PYk3b/3VpbdZxpQz7s0x6PLH/eDDkPYjk+y2kfsnV/0nL6BnWe9rFvzeZX1b6kzbJuuW3LK6uzPpdThXFM9nw5XmvPtr0+Nj1mqOkc+y0eT26b5bZTODDxGR/hNtT17ebbNku+3mb6xMM+GZlWb42Kg9QPyR+7BWa/e311z5e/bXkn1rAr3/mGtM3W/i1MtEPg8rLFgVVYCfwm2byiYb3swjG8azMAF8tpU9luEtL1NBu06EC4kn6ZfHtlOGvZ5DlRMr+msTzbnjQ/iOdEn9PYlYeZNuskHvsk+XZnz6vVCssDlK0zV0NKeKYcn+5oH9aP9UMbgYgBn6e97VtrcDziczfvuMfY3k/W/vtjUmzH6kk8t87bTnA8nz9uOMd2jf1zL3ALvsGBymw3Hwa7bS7rDYOC07jDzkxJMCbrtwU1XcdjJ/8uM1ANA+8QWP8hnN/pK9y6dWttUhtctjFRiFfbs9/zPJO205i207XJwnlLV35D2h5vaJtuxXwL7eMPMc3LbECgpboUBuvZQNYypuVuTOOtTNlm2/BV0KKLycvZhnp4K/P6oalbMzL5lWxLQyzP7IWn4w4mzSeZMg0BlIdr5Rl2oHy5NhlrfRVQR+OS9U2iVpOfbODt4kD7lmy9WQzpFqfYFr1Z6wtC3b+3VvfvrrW3X97X0cqXIufpVVfnaQxG7NO3nid04Uksi1ny7QWoeebfZ7FOXY08LyaZc2sWxzA/7GgHVmPW1tqBDWPrJPbLRdqsdzZbA4o0NGFJ8OOCy4DLvj7Ez57IaQrWx8HddhpvUcneTnPZQj5tvE1rx99nl89/aDl9j0uk7byF9u63EmlbL9tnDafveO37ipTt+fot/S2dq+u301x20F4cr906vPMW4Q23vDRdntOytxZ10Z70KViz4dbEgzn+AnXo3cDS/mat7k8LlP+Htfcct5zHvT5Pe9y31nXb6bTFsn7W8vnwrK3jbKKcajq3itTb9XbgY4v5s97+nBRoBz6s3S67sc2y8g34IlxFDQ84TV8PM1fMwpWaEOmfJd/fvrZN+NuwCiNcCVhdzbgXP3shpxnhpGgSB9whmJVdpfSk4e8Ng7Zp5vtO827hjqtGfl9V0uYtPXkPUI5puxeP46rh5DzN/PdVgbTNY5u48qjh9L3I1KV5wbINeZZdFdTFBY9FRyuTwiB+ksmvnY8zCL8LfV3s366Sb1eateF53oOkY517mPmn80O4gBUnLNn6n2TaK8+H/er9gMoz9FHZfib3rofMCsjVmPE4+XaVsvO0v30rFPGyQL1dxnNr1ZdPWror4jz5Y1Xpamw9LzhG/D2t29oswTdgW0MyiwGzJ3EJ+72124e2vU5jAO9ZGLR4nhsj8VO8Urj+ClcN158JUSgQVoNsAKjMsxOfZ/77QYuTsPMC7c68pdvRzzNlVShIGgdXq4nLcVODwMxOgKXLNk6srrfUkVYmq12dn3vmV/jbi5b7qUXRnfziuZA9H6ZjbmRj3c8+x2qefP8MOAG4JPnLkPrOtQn3vGDdD+fkRYdtWdnzdN7VedqzvhVqGyvERRtXmX+630Lasm3N85Jt1pMtbd/vBN8AIN8kDqjXX+vC4Pa0aGdd0TTT6V8VfdPalfymJwlvM//9It5+3unkee02j7IXCLLHc9Jguf6+6m2PCVN2UNv2w8oXHZTnJPlj1dtiABPMsul7v9YOjVIm8Pb7892SrysJ1p8B9y7nluJpMn5Dep5Qtg16VeaN8VxetSnHLZdt2fP0bcvn6eu+9a1Q0LyH465sP7T+bMoybVb4++xKve/agiPlDwC1eFL0SnlNfn/49h7PLFnECUKjk4SQH2nafkr+eHj1izhRmMWgwjwOxBYt5lt2AjcpmXd/y/z3jy1MrN/ukefz9JiWMb8nB3DeZY9xPoD0/rxHEOBpw3WuD9Z3NL3ITIhOM79fBeC+WV2cDd6l/z3GjRkWW+p8b8WJZ/ZCwj7tfLhY9DjTNs6cp18n+bFvnfaob4Uiyq40b7MOZ8dfsz1XxYdz8CzTVn+TfsE3AMgXlp4/2zC5eJf8EcwJA+FWgm9rKwAmybfPMOuVcMt6fPh/9vkX00y+heMJg5NwJf9ly7cAfpOOktpYZbDvRHO+Oq7wIOCWVmL2wd9HfnyjXNkS24eTzITnYq0NWRYIwF1mPmN0+RSCKNmgeghsDSCwMqkw4V75xwDr/3FLdeK0x30r1Nn2dfHV+z5bM4xDzjLn4zfjOLedAsD+ss93OMnbvamHWgnKhGdrJV+3ZH+SbA4ohUlaCCB+HNAW7UN56LlbkeituDpq1W6uHrC9qQ1ZPYT/u1tQ44Y3Z5k27WKk2dXl8xzpoZH2rTBagm8AsP/AN0z0ss/YetrSTmfZoNms4GYom173Wsyr1Y7Kp3FH5XtxknyV+bPjOKFua5JwUSHvnrWQvume7zvUSdbftEqDk30m2FXeLrXJ9wG47IY3y3hOj3WFT/Y5X+cDeMbXYq1tp52+9W4P+tZEsI+B23dzh523nQu+AUA1LzOTjNWzV5oebC+TP27jGeQAN+6+tno2093MhDrkYZOrOmY1DK6aNC86iNsx4TmkiW52gj/VHA1Oto6/LdBurAfgVnV9tcv0aG+xXtv9Nhz3Zc/Tu8j2U3sGCx9sabvZke87+tY2H1Eh4CqPhibbf+w7tt75PsE3AKg20P2y2iLzT2fpJKONXSZXtyCF267Ohz5ZSL693eyswe+arZVV3wa/6+mblHz/owM7/0LdWcT/nRzIbpdjMtmjzJfJ94GYbD0Ys+dr7UPf2/5sOZV6LEM8l1cT2eUAdjIeQt/adPuYDV48KFHWx8lhXjyxOrB/4/n5vmPr+Pc7+zTBNwCo3mGHScFV5p9etBDUed3y95UWVmEVvfVk7eHhTR/LVeZ7LntWl5ZrdemyRH6Hycv5AZ6Cr7L5NYDb8fhD6fM+TnAeb5jEvht72ce+5uVafd/rnA/va+E5pdlz82nR/iCWY3YV+bVTZRB9a/ZZqGVuje7yeblt7yK97PC7aWhsHf8ud2Wp4BsA1ONJZlA1SRq+vWPDLUiFJp5hshUeUN70JDWu/vsQXkUmh2srlpq+dex5pqzO4gPb89IXVlW9aGlTjezqlmmR8or59+ZAz72rJLP6rci5ECevb9LXM01Xp7KT9acFzsNwrmbP14tkwyYMY86w+JD9bBt5Gety0UliaMvexHxstE1b66eSpMBzx+JxvEkyq97W2sSDtta3Pi7w9631rWl5XyffPoajSFt8nrS/Y/tyrY9ts83IBpLPhn7nwsjHE0Xr8Je/Swqs5BZ8A4B6Bp1hMJfd/fRxCw8cvki+ffZb2NHs2aaBQlzlEB5OHlYThMFe00Gkk7XJ4btNt+PG3QofJ98Gjt42XFaLtbIKefNhS/omMUDzIebZi6bLNaYveyvzeZxofbeSIKbvMg78jjdMLA7l3Hu4Vvd25dezmF+hvJ96MHinrpNvnwv2ZtOt1iGAEM7R5NuVnWFzhTBR2rgL6sjz7XQtkHIW2/+t7VMMOF/GtuysxbRm+6njeG4+Wy/n2Becx/RNM796srZ669Bl8+1Fn/rWVXkVbItPMkHgtvuM+VqA5TK2MdMWvjt872xtfPRi9f0tbdrF7vHExVod3ji2zrRZHzNj3tmuz78liwHomzg5rnwlNO78VUcanhfd3TIMhDMTh7AT6WnDeXWSfBt4WZlnJjzrA8ovwYomn6GTuRK4aSI4ywx6138/b2sX1jhoutyRvkny/ZXMkK+nbeyouCN9q7LdlL4waPwpU+anDZfzu7a+q0BazmJ+HZfIr8brW5zQvSvblmx4b+PtSUfltqmez+LkeNVGTNbar282V9jQ3lynv394AH1luJiy6UJK9tlFm/qAldWD+ZtO57Z+arFWzutWAdY28nIQ5+nA+9ZlLO+TDf++zJznjfclsb/YtFr8ZVxd2uR3h+P8kGy/DfhukwHnbL9dZZzc1vmRvv+3tvvAHXV4V5t1kXx758t37YiVbwCQr8wg6KLAhKc2cQIadjRbn6CcxO+fbhicNz6wDcGpONDP3uKZzZfphoFLeJZRa8GFzKqZxZb0rU/4nyctBd5y0neyIX2LmLarCnV30OItT6fJ91eeN+VX6/WtBsuRlttV8u3qqNU5GCY/Z2vlNosT0/l6e5N8vxrsEOr8ky11/jjTjk239GkP2wi85fRTky19QTiee20F3oZ0ng6ob324IX3HW8p6vZ9btpDG6w31MUla2AQhBtZ2tVeTAx5D96lfurehjDa1Wav2NLznb5l//658rXwDoHfiFaefaug8TyukIXSwL+Ig8EmZgEsm/e/LXD2vId8mccJ6P/ljlc9qBUR4ttJVF7fvxCv1Z5l0ncRB+CK+OktbJo0hfQ/W0re6NSXcqnPdVtBtR526nxn4rSYtX9IXJxLZY3nURv2LV7TDVd5506sF9kjXg1iW6/VtVZ6LFuv/i5iG5+uBowLvv9z3vQNr949j+/Ug+TZgtIh1/XXeRYP4GSeHuDNmXF3205bgy2oiOF9vLzpI565+apW+WUf1b1Dnad/71kz6Vm3xZK0u/n5OZ/qStsdN03jerNL2pM12dm3s8aW9azoo3uYYIfOdz2I9fVW2/any3gbqyDRTh1fjr6vM337MlOW9MffZAAAAANCa+My+3+Lrl01/47ZTAAAAAA5a3ADj3R6bMWWfVX0tJwEAAAAgI+7C+/vqtaIBuHDbeeZ9v9m1FgAAAAA2OLpz58NaAO5ZfH7hpr89Tl9v1gJvj7d9tg0XAAAAADhoMdD2Lvl245qwKcwsff09828/Jl83FMm6amsXaQAAAAAYpLii7cXaira81+O8z/2TrAUAAADg0P36+fM/09d/vX109D7+0yR9/XnDn4YVcf93+nr46ebm/8n7XLedAgAAAMAGcfOF7LPflp9ubuZyBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGLX/X4ABADdvGiZHZ1RtAAAAAElFTkSuQmCC" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Conservation Trust Foundation, Society for Ecosystem Restoration Northern BC, and the Ministry of Transportation and Infrastructure (MoTI). Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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OGLECDv11FPto48+SjRXhIdAPhJgBCkfU4U4QSBmBO6++24bMGCAqcc0202ePNn0SXean3/KKafU99LW1NSYRpXmzp3LnP10UHyvJ9BSHuvbt68tWLCg3q++KI9piqZ67lu7n/EgJ4klMHXqVLv44outqKjInn322QwOx5OHtm3bZoMHD854Tud//PFHxjVOIACBjifACFLHpwExgEDsCUg5Ol6n6Sffffed3XbbbfWPLF++PIwwzZ49u/4aXyCQTqAteWzLli22bNkyu/baa4Pinh6Ovrd2P9s/58kg0KdPn6AcHY+02XlI0/O05q28vDzjcZ1r9AkHAQjkFwFGkPIrPYgNBDo1gXfffTfMsY+E0PqO0tLS6LTV48qVK+3VV1+1RYsW1c/J17qlDz74IEyvazUAPMSewInmse+//9402nT++eeHqZ3ZwFq7n+2f8/gRUAfNpk2b6gU788wzbezYsfXnrX1pKg9ptLJLly5hHVP681Kcoil36df5DgEIdCwBFKSO5c/bIRArAh9//HHGdJELL7zwuBQkLXBevHix6XkZc4jWhwiOevq7d+9ev35JVsjk7r33Xps1a5ZNnz49nPMnGQTam8dER2tAFi5caFdeeaXNmzevEbDW7jd6gAuxJCBDMLI0FzlZnDteBam5PCSjDieddJLt3bs3CjYcq6urbeDAgRnXOIEABDqeAApSx6cBMYBAbAg8+eST7ZLloYceCtPqli5dGiyKpQciC08y5BA5Lar/8ccfbcKECaHBEV3nmAwC7c1jn376qSmfaeqmzMxnu9buZ/vnPL4ErrnmGtOnra61PKT931R2qUyLnJSxK664IjrlCAEI5AkBFKQ8SQiiAYGkEtD0OY0K3HnnnaF3VdNbIicLT9nrjr755puwoex1111nJSUlkVeOEGiWwM6dO01W7mbMmGEjR44MynjkWXttyVpiS/fV84+DQEsEWstjykNShLSP26WXXhqM0Lz55pths1gZfsBBAAL5RQAFKb/Sg9hAIHEEtLeR3OOPP95I9rVr14bpdY1ucAECbSAgJXz//v3BnHK2SWWtR9IIZUv303v82/BavCaIQGt5THlI1jqvvvpqu+WWW6y4uDhY5NRUYW2QjYMABPKLQIH3nDVsNJJfcSM2EIAABCAAAQhAIFYEDh8+bFp7JNPgOAhAID8JoCDlZ7oQKwhAAAIQgAAEIAABCECgAwiwD1IHQOeVEIAABCAAAQhAAAIQgEB+EkBBys90IVYQgAAEIAABCEAAAhCAQAcQQEHqAOi8EgIQgAAEIAABCEAAAhDITwIoSPmZLsQKAhCAAAQgAAEIQAACEOgAAihIHQCdV0IAAhCAAAQgAAEIQAAC+UkABSk/04VYQQACEIBACwS0b1FlZaUdPHiwBV/cggAEIAABCLSdAApS25nxBAQgAAEIdDABbcw5cuRI++yzzzo4JrweAhCAAATiRgAFKW4pijwQgAAEIAABCEAAAhCAQLsJoCC1Gx0PQgACEIAABCAAAQhAAAJxI1AUN4GQBwIQgAAEkktg/fr1tmrVKtu6dWuYgnfRRRfZBRdckAHkueees4qKCjvvvPPsxRdftK+//toGDRpkc+bMsSlTpmT45QQCEIAABJJHgBGk5KU5EkMAAhCIJYGHH37YJk2aZG+99ZYVFhba2rVrbebMmTZ//vwMeVesWGFLliyxadOm2YMPPmjbt2+35cuX27nnnmtvvPFGhl9OIAABCEAgeQRQkJKX5kgMAQhAIHYEvvrqK1u4cKFdddVVtnnzZlu9erX98MMPtmDBAlu2bFkYVUoXet26dTZ79myrqqoKhh42bNhg3bp1s8WLF6d74zsEIAABCCSQAApSAhMdkSEAAQjEjcDKlSvDqNFTTz1lxcXFQbyCggJbtGiR9e/f355++ukMkbt27WoacZJSJDd27Fg7/fTTg+nwDI+cQAACEIBA4gigICUuyREYAhCAQPwIbNq0yUaMGBGUoXTpSktLg+KjUaV0N2zYMCspKUm/FJ49cOBAxjVOIAABCEAgeQRQkJKX5kgMAQhAIHYEdu7caeXl5U3K1aNHD6upqcm4171794xznWjEqba2ttF1LkAAAhCAQLIIoCAlK72RFgIQgEAsCZx88snNTo/77bff7Iwzzoil3AgFAQhAAAK5J4CClHumhAgBCEAAAv9iAlOnTjWNIr399tsZb5bxhY0bN9rEiRMzrnMCAQhAAAIQaI4AClJzZLgOAQhAAAKdhsDtt98e1iDdeOON9vzzz5vWJK1Zs8ZmzZplo0aNsjvuuKPTyEJEIQABCECgYwmwUWzH8uftEIAABCCQAwKyRvfll1/avHnzbO7cuXbs2DErKyuz6dOnBzPfQ4cOzcFbCAICEIAABJJAoMAXpLIiNQkpjYwQgAAEEkJAlui07mjMmDH1Jr8TIjpiQgACEIBADgigIOUAIkFAAAIQgAAEIAABCEAAAvEgwBqkeKQjUkAAAhCAAAQgAAEIQAACOSCAgpQDiAQBAQhAAAIQgAAEIAABCMSDAApSPNIRKSAAAQhAAAIQgAAEIACBHBBAQcoBRIKAAAQgAAEIQAACEIAABOJBAAUpHumIFBCAAAQgAAEIQAACEIBADgigIOUAIkFAAAIQgAAEIAABCEAAAvEggIIUj3RECghAAAIQgAAEIAABCEAgBwRQkHIAkSAgAAEIQAACEIAABCAAgXgQQEGKRzoiBQQgAAEIQAACEIAABCCQAwIoSDmASBAQgAAEIAABCEAAAhCAQDwI/D9fxa8Wy/uhzQAAAABJRU5ErkJggg==" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650784
</td>
<td style="text-align:right;">
5934858
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
