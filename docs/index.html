<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_skeena_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.com/fish_passage_skeena_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.com/fish_passage_skeena_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-08-05</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit/raw/main/mapping/sites_skeena_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Trust Conservation Foundation, Ministry of Transportation and Infrastructure and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from the Office of Wet’suwet’en (contact Julia Onderwater - <a href="mailto:Julia.Onderwater@wetsuweten.com" class="email">Julia.Onderwater@wetsuweten.com</a> or Dave Dewit - <a href="mailto:david.dewit@wetsuweten.com" class="email">david.dewit@wetsuweten.com</a>), Gitskan Watershed Authorities (contact Alicia Fernando - <a href="mailto:afernando@gitksanwatershed.com" class="email">afernando@gitksanwatershed.com</a> ) and Gitsxan Environmental Services (contact Chaz Ware - <a href="mailto:chaz.ware@gitxsanbusiness.com" class="email">chaz.ware@gitxsanbusiness.com</a> ). Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, cutthrout trout, and dolly varden. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
460-517700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
641633
</td>
<td style="text-align:right;">
6049398
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
460-636000-36664-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
654312
</td>
<td style="text-align:right;">
6012383
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
460-185400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
605786
</td>
<td style="text-align:right;">
6099884
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
460-600600-07100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
643460
</td>
<td style="text-align:right;">
6025890
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
460-600600-36400-26300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
623369
</td>
<td style="text-align:right;">
6000283
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
400-448500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
582874
</td>
<td style="text-align:right;">
6130541
</td>
<td style="text-align:left;">
KISP
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
CT;DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
DV
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Bulkley
</th>
<th style="text-align:left;">
Kispiox
</th>
<th style="text-align:left;">
Kalum
</th>
<th style="text-align:left;">
Morice
</th>
<th style="text-align:left;">
Zymoetz
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus sardinella
</td>
<td style="text-align:left;">
Least Cisco
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Entosphenus tridentatus
</td>
<td style="text-align:left;">
Pacific Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Gasterosteus aculeatus
</td>
<td style="text-align:left;">
Threespine Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lampetra ayresii
</td>
<td style="text-align:left;">
River Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout (Anadromous)
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii clarkii
</td>
<td style="text-align:left;">
Coastal Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus keta
</td>
<td style="text-align:left;">
Chum Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Summer-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Winter-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
E/T/SC/DD/NAR (Nov 2020)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii pop. 3
</td>
<td style="text-align:left;">
Giant Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Pungitius pungitius
</td>
<td style="text-align:left;">
Ninespine Stickleback
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Cutthroat/Rainbow cross
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Verified DV BT hybrid
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
