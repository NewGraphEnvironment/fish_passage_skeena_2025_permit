<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_skeena_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.com/fish_passage_skeena_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.com/fish_passage_skeena_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-08-06</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit/raw/main/mapping/sites_skeena_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Trust Conservation Foundation, Ministry of Transportation and Infrastructure and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from the Office of Wet’suwet’en (contact Teagan Oshaughnessy - <a href="mailto:teagan.oshaughnessy@wetsuweten.com" class="email">teagan.oshaughnessy@wetsuweten.com</a> ) and Gitskan Watershed Authorities (contact Alicia Fernando - <a href="mailto:afernando@gitksanwatershed.com" class="email">afernando@gitksanwatershed.com</a> ). Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, cutthrout trout, and dolly varden. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
460-517700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
641633
</td>
<td style="text-align:right;">
6049398
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
460-636000-36664-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
654312
</td>
<td style="text-align:right;">
6012383
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
460-185400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
605786
</td>
<td style="text-align:right;">
6099884
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
460-600600-07100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
643460
</td>
<td style="text-align:right;">
6025890
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
460-600600-36400-26300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
623369
</td>
<td style="text-align:right;">
6000283
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
400-448500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
582874
</td>
<td style="text-align:right;">
6130541
</td>
<td style="text-align:left;">
KISP
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
CT;DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
DV
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Bulkley
</th>
<th style="text-align:left;">
Kispiox
</th>
<th style="text-align:left;">
Kalum
</th>
<th style="text-align:left;">
Morice
</th>
<th style="text-align:left;">
Zymoetz
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus sardinella
</td>
<td style="text-align:left;">
Least Cisco
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Entosphenus tridentatus
</td>
<td style="text-align:left;">
Pacific Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Gasterosteus aculeatus
</td>
<td style="text-align:left;">
Threespine Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lampetra ayresii
</td>
<td style="text-align:left;">
River Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout (Anadromous)
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii clarkii
</td>
<td style="text-align:left;">
Coastal Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus keta
</td>
<td style="text-align:left;">
Chum Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Summer-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Winter-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
E/T/SC/DD/NAR (Nov 2020)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii pop. 3
</td>
<td style="text-align:left;">
Giant Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Pungitius pungitius
</td>
<td style="text-align:left;">
Ninespine Stickleback
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Cutthroat/Rainbow cross
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Verified DV BT hybrid
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
