<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_skeena_2023","repo_url":"<a href=\"https://github.com/lucy-schick/fish_passage_skeena_2025_permit\" class=\"uri\">https://github.com/lucy-schick/fish_passage_skeena_2025_permit</a>","report_url":"<a href=\"https://lucy-schick.github.io/fish_passage_skeena_2025_permit/\" class=\"uri\">https://lucy-schick.github.io/fish_passage_skeena_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABN8AAAGRCAYAAABVBRUGAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAV3pJREFUeNrs3T+UE0m+KOiEqXOYtabaG2+Et14X3l0LlXfXovDuWl1lrgV4uxZgPguwdteqwnr7LApvn4Ww9j0LjXc91N5dqzXe1DnQvRkQ6k6EpMxU/k993zk61U2VpMiIyPjzy8iMJAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgKM7d07S14sepec8vJQMAAAAAIMWA2+/pK/f+hCAi4G33+LrXAkBAAAAMEhrgbfOA159Sw8AAAAA7GVLoGv1mnaQnuMd6TlXYgAAzbstCwAAqguBt/THu/R1vOVP3oRgWMvJerMjPZcCcAAAzRN8AwCoqEDgLYm/e9Nimp6lP6Y5fyYABwDQsD/JAgCA/RUMvK1Mbh8d/ePXz5//Wwtp+s8F//wsTdPPaZrmShMAoH63ZAEAwH5KBt5Wlunr7qebm2WD6fqQ/jgp+baLNE1XShUAoF5uOwUA2MOegbck/v2LBtN1npQPvAVuQQUAaICVbwAAJVUIvGWF1W+LmtMV0vOxYrqsgAMAqJGVbwAAJdQUeAueNpC8xzWkywo4AIAaWfkGAFBQjYG3lVpXv6Xp+6XGtFkBBwBQAyvfAAAKaCDwFjytMX3nNafNCjgAgBpY+QYAkKOhwFtQ286ne+5wWoQVcAAAFVj5BgCwQ4OBtyR+5lkNaZwkzQTeAivgAAAqEHwDANii4cDbyoMaPuOs4awQgAMA2JPbTgEANmgp8PbFp5ubWxXT2tQtp+vcggoAUJKVbwAAa9oMvMXvO6vw3pDGk5ayxgo4AICSBN8AADLaDrxF9yu8d9pyFgnAAQCUIPgGABB1FHgLqqxcu99BVgnAAQAUJPgGAJB0GngLphXee9JRlgnAAQAUIPgGABy8jgNvqzRM9nzrSYdZJwAHAJBD8A0AOGh9CLxFkz3f13W6BeAAAHYQfAMADlaPAm/BZI/0T3uSlQJwAABbCL4BAAepZ4G3YDLwLBWAAwDYQPANADg4PQy8jYUAHADAGsE3AOCgjCzwdtLDNAnAAQBkCL4BAAdjhCve+nocAnAAAJHgGwBwEEZ6q+myx2kTgAMASATfAIADMOJnvM17nj4BOADg4Am+AQCjZnOFzgnAAQAHTfANABitgQXeFiMuCgE4AOBgCb4BAKM0wBVviz3eMx9QkQjAAQAHSfANABidgd5quij7hk83N8uBFY0AHABwcATfAIBRGeoz3j7d3Cz2fOtsYEUkAAcAHBTBNwBgNAa8ucKswnvnAywqATgA4GAIvgEAozDwXU2rBND+PtAiE4ADAA6C4BsAMHgDD7wF7yu8dzbgohOAAwBG75YsAACGbASBt/C8t1sV8+Bj+mMy4GK8SPPgSm0GAMbIyjcAYLDGEHhLXffkM7pkBRwAMFqCbwDAII0k8Ba8reEzXo+gSAXgAIBRctspADA4Iwq8LdPX3U83N8sa8uRD+uNkBMXrFlQAYFSsfAMABmVEgbfguo7AW/RqJEVsBRwAMCpWvgEAgzGywFsQVr0tasqbkCcfR5Q3VsABAKPwJ1kAAAzBCANvV59ubmp7Vtuvnz//8/bR0f+Q/ud0JPlzlh7Pz+lxzdV+AGDIrHwDAHpvhIG3oLZVb5l8Gtvqt8AKOABg0Kx8AwB6baSBt1pXva2McPVbYAUcADBoVr4BAL010sBbbTuc7si3sPptMrLqYAUcADBIdjsFAHpppIG34HmTgbfoYoRVwi6oAMAgue0UAOidEQfeZp9ubv7Xpr/k18+fF7ePjkLe/cvI8s8tqADA4Ai+AQC9MuLAW1jt9j+F57K18WW3j47+e/rjX9PXX0eWjwJwAMCgCL4BAL0Rd+v8kIwv8Bb8z59ubv69rS+Lmy+EANy/pa8/jywvBeAAgMHwzDcAoBdi4G2MK96CsFnArO0vTb8zBKcuRlplPAMOABgEK98AgF64fXT0n9Mf0xEe2stPNzf/qasv//Xz538Pq8TS/zwbYd5aAQcA9J7gGwDQuaM7dx6nPx6P8NCu2thgIU8ITgnAAQB0Q/ANAOhU3GDhzQgPLQTeenPLpwAcAEA3BN8AgM7E57yFwNvYduQMz3h73rdECcABALRP8A0A6Mzto6P/Lfm6G+eYhMDbVV8TJwAHANAuwTcAoDVhpduvnz//M/73JBnf7aa9DrytCMABALTntiwAANoQN1XIuhzZIQ4i8LYS03ox0up2mda3c2cdANAHt2QBANC0ozt3nqU/Xn66uVnG/5+mP96N5PDCMZ2mxzYfaNmcJ+MLhK4MKiAKAIyT204BgEYd3bnzIv3xXz7d3CxW/3b76GgsmywMOvAWuAUVAKBZbjsFABpzdOdOWFH1PhucSv8tBHlORnB4gw+8rbgFFQCgOVa+AQCNiIG3nz/d3Pyf2X+/fXT0f6Q/JgM/vNEE3lasgAMAaIZnvgEAtYuBt5NPNzf31v59mgz/WW8hgHO6en7dCMvuPPEMOACA+sZXsgAAqHVw8TXwdp6+7m349U8DP7xRB96CEJxKyzD85xgDcOEW1EQADgBok2e+AQC1yQTeXq7fkpn+7jgZ9i2Now+8rXgGHABAfTzzDQCoRSbwFoJTD3/9/Pmf2d/fPjr6t/THvw308A4m8LbiGXAAAPWw8g0AqCwTeAtebQlSPRjo4V2FZ9cdUuBtxQo4AIDqbLgAAFSyFngLAaq764GqeMvpLwM8vBB4u1DGNmEAANiXlW8AwN7WAm/B9ZYVYtMBHp7AW2QFHADA/gTfAIC9bAi8Bc+3/Pn9gR2ewNsaATgAgP0IvgEApW0JvM0/3dwstrxlOqDDuxB420wADgCgPME3AKCULYG34PWOt50M5PA8/yuHABwAQDmCbwBAYTsCb8Fsy3umAzk8gbeCBOAAAIoTfAMACskJvC0/3dzMt/xuMoDDE3grSQAOAKAYwTcAIFdO4C2Y7fjdpMeHFnZmvSfwth8BOACAfIJvAMBOBQJvwd93/O7Hnh5aCLyd7lixRwECcAAAuwm+AQBbFQy8BbsCWMc9PDSBtxoJwAEAbCf4BgBsVCLwFiwHdGgCbw0QgAMA2EzwDQD4TsnAWwi8zAZyaCHgdlfgrRkCcAAA3xN8AwC+UTbwNiAh4BZWvC2VcnME4AAAviX4BgD8TuCNOgjAAQD8QfANAPhC4I06CcABAHwl+AYAjDnwdvXp5uaewFs3BOAAAATfAODgjTzwdqGEuyUABwAcOsE3ADhgLQXeuthZVOCtRwTgAIBDJvgGAAeqzsBb+lknO379j5YPTeCthwTgAIBDJfgGAAeogRVvxzt+N2vx0C4E3vpLAA4AOESCbwBwYBq61XTXyrdFS4d2EYM79JgAHABwaATfAOCANPiMtx+3/eLTzc0iaT4AJ/A2IAJwAMAhEXwDgAPR8OYKJzm/nzV4aAJvAyQABwAcCsE3ADgALexqepJ+x67nvr1v4DuX6etU4G24BOAAgEMg+AYAI9dC4G3lbMfvrmv+rlXgbaaEh00ADgAYuz/JAgAYrxYDb8Hy18+f3276Rfrv/7x9dDRJ8m9PLfQ9ydfA21wJj0NaP+Zp/fg52R3AHaqzcGzhGJU0ABwmK98AYKRaDrwFeYGT1zV8h8DbSFkBBwCMlZVvADBCHQTegj/vWuGT/vsi/X0I0P11z88PnxsCb/+uhMfJCjgAYIwE3wBgZDoKvK0c//r589YVbrePjm6S/QIrq8DbfyjhcROAAwDG5pYsAIDx6DjwtnL3083NYkca36U/piU+bxV4Wyrhg6rLoR5fjvTwLuzSCwCHw8o3ABiJngTeguNtGy8EcVVT0XQKvB0oK+AAgLEQfAOAEehR4C04uX109PrXz583Bszis9+O0//8l5zPuUpf/4vA2+ESgAMAxkDwDQAGrmeBt5W81W//Pf3xb+HvtvzJ1aebm4v0M/6phA+bABwAMHSCbwAwYD0NvAVh9dv7sMpt0y9DUC38PvkagPvz2q+/BN6ULpn6IgAHAAyW4BsADFSPA28rJ79+/vx/bftl+rv/uH109P8l3wZUBN7YVl8E4ACAQRJ8A4ABGkDgLfjr7aOjf/z6+fN/2/YHawGVJ59ubv53pUvB+jI2AnAAMFK3ZAEADMtAAm8rYbOEsFvpPOeYJunfLJQuBc+BUP8vR3p4F+m5cKWUAWA8rHwDgAEZWOAtCM9z+5fbR0f/ZdfmCdt2RoUt9cUKOABgMATfAGAgBhh4W/lreO3a/RTKEoADAIZC8A0ABmDAgbeVk7znv0FZAnAAwBAIvgFAz40g8Lbyr4IJ1E0ADgDoOxsuAECPjSjwlnUvbwMG2ONcCeeJTRgAgN4RfAOAnjq6c2ea/ng3wkMrtAMq7HHOnCfjDcDdtSMwAAzTbVkAAP2UTrRn6Y+LER7acfp6d3TnzolSpuZz5mqk58yFwBsADJdnvgFAj434eVZ/Tl//lh7bf02P8T+UNDWfMyHA+y8jOSS3nALAwLntFAAGYMS307kFlabOmTfJ8IPWAm8AMAKCbwAwEAJwUOp8CavfPiZfb3MeIoE3ABgJz3wDgIEY8fOsPAOOJs6X5YDPF4E3ABgRz3wDgAHxDDgOXVjRltaT/zd93YTzIed8+ff070JQ938c0CEKvAHAyLjtFAAGyC2oHGi9/7JKMn2tVkmexl2Bd71nkv74kAzj9lOBNwAYIbedAsAAuQWVQ7Mh8Ba8yasr6bmySH+8GsAhCrwBwEhZ+QYAA2YFHAdSzzcF3lbmsa4sc97f580XBN4AYMSsfAOAAbMCjrHLCbwl8d8vc86TEJi76ukhCrwBwMhZ+QYAI2AFHCOt13mBt6yHaT253vFZk+Tr6rc+EXgDgANg5RsAjIAVcIxNycBbcBnfs+0cWaQ/rnt0iAJvAHAgBN8AYCQE4BiLPQJvq3ryIudvXvfkEAXeAOCAuO0UAEbGLagMvP7uE3jLurerjqSf/0vS7cYLAm8AcGCsfAOAkbECjqGqIfAW5K1+6/LWU4E3ADhAgm8AMEICcAxNTYG3YJpTP952dIgCbwBwoATfAGCkBOAYiliWdQTeVh7t+N2sg0MUeAOAA+aZbwAwcp4BR8/r5yrwVvdz2H5I68Zyy3eG75u2dIgCbwBw4Kx8A4CRswKOvmow8Bac7fjd+5YOUeANABB8A4BDIABH3zQceAse7PhdG6slBd4AgC/cdgoAB8QtqPSkHjYdeFvZeOtp+v2T9MfHBr9X4A0A+J2VbwBwQKyAo2stBt6C6ZbzYNHgdwq8AQDfEHwDgAMjAEdXWg68Bfd3/G7WwPcJvAEA3xF8A4ADJABH2zoIvAVt1gOBNwBgI8E3ADhQAnC0paPAW7CrDtS546nAGwCwleAbABwwATia1mHg7Us9SL+/6e8VeAMAdhJ8A4ADJwBHUzoOvK00Wf4CbwBALsE3AEAAjtr1JPDWJIE3AKAQwTcA4AsBOOqS5vV5IvAGAPCF4BsA8DsBOKqKgbfLpD+Bt2nNnyfwBgCUIvgGAHxDAI59ZQJvYyXwBgCUJvgGAHxHAI6yehx4W9b0OQJvAMBeBN8AgI0E4Ciq5yve5lv+/S8lPkPgDQDYm+AbALCVABx5BnyradGyF3gDACoRfAMAdhKAY5uBP+OtyIYQAm8AQGW3ZAEAUMSIH6Yfngl2+unmZq6Ux1cf0nK9tSX9v+W8VeANAKiFlW8AQCFWwLEyoEDsckv6pznvE3gDAGoj+AYAFCYAx8BWQG5bzbirnAXeAIBaCb4BAKUIwB2uAd56/H7Lv9/f8u8CbwBA7QTfAIDSBOAOz0Cf+TffcByhjM82/K3AGwDQCME3AGAvAnCHI82LEHQb4mYbsw3/JvAGALRK8A0A2JsA3PjFwNv5AJM+T+vnpg0XHqz9v8AbANAowTcAoBIBuPEacOAteL3heCbJtyvfBN4AgMYJvgEAlQnAjc/AA2/B9YZ/e5r5b4E3AKAVt2QBAFCXgT6Uv4hw++Lpp5ub+YGU49ADb7O0rE7XjmmS/vgY/1fgDQBojZVvAEBtrIAbvhEE3oLXG/5ttepN4A0AaJWVbwBA7ayAG2y5jSHwtkjL5+7acU3TH+8SgTcAoANWvgEAtbMCbnhGEngLXq8dVyizcGwCbwBAJ6x8AwAaYwXcYMppLIG3UC5303JZrh3be4E3AKArVr4BAI2xAq7/RhR4C56vBd7CcQm8AQCdsvINAGicFXC9LZcxBd6+edZbemxn6Y9jgTcAoGtWvgEAjbMCrl/Cc9BGFnhLNtSvpcAbANAHVr4BAK2xAq4XZfAlYJi+xrRpxHWa9w+dYQBAHwm+AQCtEoDrNO/HGHj7bpMFAIA+cdspANAqt6B2Y6SBt+ChwBsA0GeCbwBA6wTg2jXiwFvY3XTmjAIA+sxtpwBAZ9yC2koejzXw5jlvAMAgWPkGAHTGCrhmjTjwNh9pvQEARkjwDQDo1AEE4CYdpuFFMr7A2yL5uqrQc94AgEEQfAMAOjfyANybuAKtVel3hsDb+cjyMwTcbLAAAAzKn2QBANAHv37+PL99dPRz+p9nIzu0v4ZXenxv2/rCozt3Qh6+HFk+9uY5egAAZQi+AQC9MeIA3El6XH9Pj+/fm/6izHPe/jyi/BN4AwAGy22nAECvjPgW1MuWbj8Nu8cejyjfBN4AgEETfAMAemekAbgQEHvR5BfE203HtGpQ4A0AGDy3nQIAvTTSW1DD7afv02Nb1P3BcVXdm2Q8q94E3gCAUbDyDQDorZGugHva0Oc+Tl+TkeSRwBsAMBq3ZAEA0HdHd+6cJ1+fZTYWIbA0qzF/wmq3j8k4Vr0JvAEAo2LlGwDQeyNcAVf36rew6k3gDQCgh6x8AwAGY2Qr4O5+urlZ1JQvYdXbZOD5IfAGAIySlW8AwGCMbAXcozo+JO5wOhl4Xgi8AQCjJfgGAAzKiAJwde3i+tPA80HgDQAYNbedAgCDNJJbUCttvBA3WvhlwMcv8AYAjJ6VbwDAII1kBdyDiu8/G/jxC7wBAKMn+AYADNYIAnDTiu+/P+BjvxB4AwAOgdtOAYDBG/gtqD98urlZ7nncQ93l9CIGTgEARs/KNwBg8Aa+Am66z5uO7tyZJAJvAAC9J/gGAIzCgANwJ3u+bzLAYxV4AwAOjuAbADAaAw3A/bjn+6YDO06BNwDgIAm+AQCjMsAA3PGe7/vbgI5R4A0AOFiCbwDA6AwsADf2204F3gCAgyb4BgCM0oACcMcjLgaBNwDg4Am+AQCjNfBdUPOc9Dx9Am8AAIngGwAwciMOwPV5xZzAGwBAJPgGAIzeyFfA9Y3AGwBAhuAbAHAQBOBaIfAGALBG8A0AOBgCcI0SeAMA2EDwDQA4KCMKwM16lBaBNwCALQTfAICD07MA3HLg2SnwBgCwg+AbAHCQehSAm+/5vkUP0v5S4A0AYDfBNwDgYPUkALfY830/d5zuqzT/nqhFAAC7Cb4BAAetBwG4fYNo8w7THAJvNq4AAChA8A0AOHgdB+Bme76vq+CbwBsAQAm3ZAEAwFdHd+6cpz8u2/zOTzc3tyqk95f0x3GLyRV4AwAoyco3AICogxVwVVevzVpMq8AbAMAeBN8AADJaDsC97fj9RQm8AQDsSfANAGBNiwG464rvn7WQRoE3AIAKBN8AADZoIQC3SL9jXjGNi6TZAJzAGwBARYJvAABbNByAe1XT57xuKH0CbwAANbDbKQBAjoZ2Qf3h083Nsoa0hd1OPyb17noq8AYAUBMr3wAAcjSwAu6qjsBbTFv4nKua0ybwBgBQEyvfAAAKqnEF3N34vLa60jVJvq5+q0rgDQCgZn+SBQAAxfz6+fP89tHRz+l/nlX4mBDgel1zupZpusJtp/9SMV0CbwAANbPyDQCgpAor4MItovfqXPWWSVOVZ78JvAEANMTKNwCAkiqsgPtPn25urhtK0z/TNN2k//mvJd8q8AYA0CAr3wAA9lRyBdz8083NvRbS9CH9cVI0TenrtK7NHwAA+J7dTgEA9lRyF9S2VpcV/R6BNwCAFrjtFACggoK3oD5p6nbTDen5jzQ9/0h2334q8AYAAADAcIRbUNPXbxtelx2l53JLej7EzRkAAAAAYDg2BOA6C3SF743fL/AGAAAAwDhkAnCdB7rWAnACbwAAAAAM39GdO2d9CXSl6ThJX28E3gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgHrckgUAAMDK0Z075+mPB+nrOPPPbz/d3LyUOwBQnuAbAAAQgm4h2PYmfU23/Mk8fZ1+urlZyi0AKO62LAAAAFKXyfbAW3CSvt7JJgAo50+yAAAADtvRnTshsFbkttK/3j46+vnXz5/ncg0AirHyDQAAOCvxtw9kFwBDEx6vkL4u09eH9PUxfb1JX2etfLfsBwAASjiWBQAMSXyuaXh0wknmnyfp6yz93cWnm5urRr9fEQBA7wcLYZDwournpIOKU7kJAMABepx8G3jLepGOt6+b3FBI8A0A+i9cqZvKBqBBixJ/63lvAAzN/ZyxdgjMzZr6cs98AwAArtNX0Sv+r2QXABQn+AYAAAcu3mrzpMCfPk//diHHAKA4wTcAACCJD5u+SDavgPsSnEv/5pmcAoByPPMNAAD4IgTgwkOn0/88S77uAhcs0lejD6IGgDETfAMAAH4Xg2xXcgIA6uG2UwAAAABoiOAbAAAAADRE8A0AAAAAGiL4BgAAAAANEXwDAAAAgIYIvgEAAABAQwTfAAAAAKAhgm8AAAAA0JAjWQAA0MKg686d4/THSXwdb/mzZfqap6/Fp5ubxUjzYZrJg7+lr8na8f89/vcqH+ZqT6m8XR5ynqV5sDrHJhvqVzinfo4/513lU5rGSUzXrrYgmB1SeWbayGn8p23lt8qbMbeTk8yxn2TaxKSL445ty8o0lsUqDeFcWo64DIr02WPNg/Vxy64+e9TnZB1uyQIAGMSE+l3Vz0kHRPr99getZ+nrfpysTEp+xDIOZt+mr+uuBvbpcYRjeJFJfxhYP0/Tc1ViAhM+46fMJLKX+RDT+jR9ne9zrB3WtWfpj0eZCWJI90Wa7lmFNudFprzC571KP+9lg+n/aa2OFf6+WEcfxHp2XOKrw/e8Tr/nWQuT+GxbcLzHx4SyfB/PgXmP6t7jWPcm+9S9GCz9KebLvu3DdSZvlh3nx3StLr8tUo/X6shZiXZxddyLGo9hn76rF/1VTcf9YM/zdLHKg/T4rzs8jk199pOiaarpnOxlXUiP7V3yR3B/k9N9+80ibg3gBMgW+KgiqWtXNJJMRcgW+Cij6PS+bmav8Kz+e1Uvl1Yh7NWOtdJ+rZXdNPnjipyyG3D970PwbS1fkiYHJyOoQ6vJ13nNH30VAxLzFo8lDOLfbPn1w12D+ZgPT3MGuvu4jvkwq/lYw5jsw5YJ12lf63ya7lDPLrf8+l7Z+pLT3jypOwAXgzcvtvz6YlfgMx7706R8YHvdPJbxssbjWk3kH+05gc2b5L9OXy+7nCfklN3OcyaWXd15swrEPe9izrjjXAzzuXs7zrdHSbGAW6PtYubiQ9kgdq/KYc8+u44y6DwPcvqDLs7JTsYuO46xv8G3WBGrDpgWRa4WrkX7T3I60d+Xd6av911Glks2ZtPM8ZWt1LPV8Yb/bqKjjVcdK59cVRuYeOJPakjLouqV6lhu513nSUvBhtWKhKLn/DzWy0LnYE3lOivTINZUfkmZK+Jxorq6Upg9z583cWV9x/cVKbvXRTrCmtqGsmVXR/9TqOxi/c/mY+31v6aBYSvBtzhhzPZX0wJ5ke2fej/QbrgtfZHUH2zaNCa4aCmg/2FH2xL62btb6uvTlvLheV0D5TTdlzv6jFC3T3ta7z7u6F/DqoOHJT/vzY5JaLgA8UOL6d8YtIh17LKm8WJ2vHZRw/GENnS1Guy4hSpwlXQXbPplxzFurHsbVuWMIl9iuX/ckR/fBJLjGPVFzQGf1XE/KTNXjGl/kdR/waix8W+NY6s2+qrW6mLPz8lGxy4bVoC35Tqec7nHdavAATytYcJ1mjMhrxph7WV0PTZk58n+t1nkFfLbOm+DyBn8tNbA5jQatU80c9Ky64peobpZ9yC15vr5OPl2aXyVc/BVsuMKbIErDbXXr7YCFgWvFNY2+MgEFesou0Usu6sdZfdb24OvmvqfnWVX44qJZfLHVb2mBhSN1+Uar/yGwdXrvt+m10B7+jS2qW163sLtcr8VrVMd5sPLmBfLisfa6RXxPdMc2rHLfcfhe7b59+pcwdCjOlY5wBonsZcdTP6WsQ961mLdy+uXvhkDx7HLZQuBjk6CPzmrhL8JfLRQT5YxyHHdkzo7j+npxd0XsR25TOoPfOaVyfOmbt2PxxXiDR9Ktqdt50Mj52Rd84aK86l7eeOQ2x1W+vMY7AkFXjUwtQpyfQxXLWPj3uUJPYlXTz8m3z4vo05fGsoQqAqVLZ48lQcdNXzGjzUEFY5rLItpl8dTU57W3uHEBupjTYGH1Tn4NJ6Dz5IDEfPyRczL86YH2w2V3SS2Ux/jJO4Qyu0s0//UVf8fZ/qg44HlxzQGHd7VNACbxv7pYw1t8BDybzXYfdzB1z8NK9O6Hvf0IB/Cd36IaWjSox5WwZ8KTPjqdtxRHTuO7dTjHrYDx7EdfdNR/hxn2oOTnmTLcbbfje1DF33CKl+aLpeTIvkRx41N15Pw2W/yxnVxvtpGnQ15864PdTOOSz4m7QecvqwuDCuLG6yLxwPIh6bGLl33z5MieXm7gwp/Em9hqHup+Mp5HIA97uDYshPjxifiG4IeVY/5bQsdT5FJW52mNZxIVbzv2yQ7Dn6eNlQ/+zj4a7rzftzS950lfwTdmmpLQsDk3dCCRyXb6DdxoNlUsOI8tsdnA8mPF3Ey28SEaBIH229GXKfOY/5NOkzGSdJO4Cmvfeo6H1b1rUpdfp3z+7M+BDrX+qG84307knNtFXhrsp6/3TNtJ7F/nvYgq1ZBjvOetZNdBSWz+fKx67FpDHa1OUe93HZRPOc2+6bGme867qsex3aky7p41oN8OO9BPtQ9dunDODN3fHC75YI+a6HjXGX+izZXIKwFNbqwOuZ3FQaGszoqXcU8v19zvlRduVZ1INWb5xHGzretyVFvrnA1nJdttS9tXCXN1vmPYyu72C7WtbKrSHv8ps+r4GL5trWC5GyM7UHmdr99y3gR+93sazG0SU1PJtbr+bDXeR5vlc4rg6c9qoZ5V/oXY7j9u6XA29U+t4PF+v+hhvq/rKEdyJ4Hl324E6HAbdFdtA9d9UVhfHXewfc+XQ/GdhB460NfFY65yqOE6uyzT5Ju++wxnpN92KAytz4cjbygw3eGlXanDW9LX/W5YHU37CGKfFH2IeAhj9L3zWsY3Jwk+wfypg3kR5XJaaUTsC/PIOyokz2OdfF0TLsitpmXLU04dnWGp2PYHTVnB8PB90F7tm1tX/E8GVmd2mdME447rKya57WJsYxC/1XmmbFdnbdl8mEVYHgf8+O73YPjxczVLtFlNkH5Jk3p5yz2zIfnOccUHpvS+TOGMxuV5R3LGBR9hMvqGdB/j/VrvqntzexC/vu5uU8bXWFus4jpfB+/e7FjDLBqCx7sMRYIQZe/1bGJREvtwyq4sSq/b8bRmfxY/dwnT1bt5N0+9csbrNrJJDOnWrWF+7SLoU0MdW0eL+iWGccuM+Wy2vRwVQZ/Scpt+LUqg8s2x0Z7jt3DMYfVsLO8viSzCrlMneyqLlY5J7/ps2s+J+9V7Fevkm4fSbDqf3bXxR4PUusc8Icrsqc9OpnbmDi/iQG4q5LvfZvUc+vobI+8DOme1J0XYRKz5wC8aj7M+lAZcnaqa0Ooi73cIa7P53uHgbfvBgUDL7PjpNtVOdmg07IH+dFF4G1ok568PDwrOaYJ/XCpYE3ss8LrZWZDl/OCefwmDmL7lMchD94WuSiYCUxeZ87hkOdlNueqUteuY7Bn1zkSyuJZx3matwJvOaJNT/Lqfqgzr4pedI51YlaxHdhnbnMV0zkvmc7wepbZbKnMbn4hWPxzX3ebLJMva+V2ncmTVfswKdM+pK97PcuH0EeEgPn1lnZrtja2OUvKPf83BLyelwhQ5J1X15n0lK2bJzHtT1qKQ5QZu79MSm6gFfut1Xm6OrazonWxbxdpK56Tx5m6UOacfFMlH9L3PUnfv+ov2h7jhjwotMNwG7edTpLuV4VNY5R/sBPxPV3u8cyHWQ3fu++tntOmyr/l41jp/DkrsY52favXcdKf5c1V8vJZy+f7u56U3ZuBF10fzoFVAO64J/lx3HGdejfgdmBSoj0Lg9YQBLuocjU3vDeuXLkXP7PIuKsv520YjN+NeXC95/F/CSKlr3D8D5Pit/ns1ffEwfOrnD971OX5nJnc7PIqGb9wPoTJ2um+9WvP/D8pObfJngfzim1BGIvcTcqtanza0w2VrqrmS8yTl+kr5EkI5BSduJ/0aIOwZZy4341t3bLAca+C6/dK1IWTgn3Doux5lamb90rMJR83fdtl/PzLkufpk4p99jzuantasL9aBevGck4uM+fkRZlzsmo+xLL7Iezouu1VoH6e7nr/llfhOw7aCr71YcLxuM5d1wYQePt9olWmw42R+6qR930b0vsN5cH9lo9jZdZlwXcQLMrLy2kyUHGly9MWv68PAaOVwZZbdNajc+CyJ+noPA0D3hW56CrKsNLtXp23f8YB/b04OM49b7vYeGptMvkwTEDqvD0zTgSL5sGX83/P57+9zBkLrXY47mxMWyD/XybjtjrHWh1rlVxN3dR5sMwE4Yq2MS969NzNRZzgXtScLy9jnhStE097kCerizQvK9aFum4tvo7pme2ZnhCEOy3RRr9o4Vwt4kkD5+ks9ldFApiPO94dvqlz8iqek0UvjnSdD427nRyWy5pO5sfJMAJvvx93yc6l6kBm300XmjrZ9u1Yq6Rn3uXy4dhwPU3oVdtRsOzOB9a+UNxZxwGRPnnap10jC56bzwr2JxdN3uIVV8FdFMzjLi5+rlYjXTd0/MsSebDX5K7g6refOqqHoUzzNlq4GvKt3V2fYwXGA5OC58G9JlfkxUBH0WB0X+5CWOXLrMH2oRfBnxJt5aKG475KqgfgrmIAallDei6S4heKmhoLFLkldxUgf9lgfXxYMC8uR3xOPixxTo56/npowbdJ1avteyw174sytzy9r+H7Tlp6T9Fyn+xRzlXMuiroWM6XCXVqa1fTyUDbF0oMBocWdGoyL4aS0IIBj1VQ4Krp9MTvyJssHHeQx6vJ5LylPCgy2ZzsecvdVUOfW9VZgT5pzLecXnT1LLt4YfOsxHmwaCNdJQIdXa86XuXLskd5Mu1opc2i7ryI58W+m6zM696YI35ekfnQ0wbO1TCPK3Kx82Ebt6wXrI+TDs5P52TLDi34FlS9UjnU5x8dl5jU19EIlTppWjjJyn5+1eBbl897K/PwVfol7yHfDJ/g+B/OBxSILHJuPm8zKBCebVKgv37cYh6HwftFmyuuCgYh95rcxcDJVd2fW1Mfv8tVX3Zab8DzjjeRKNJ2tzaZ3XNi+6ijdrf1fIl5ct1E+1CDRtrKuCK07MWPL6u/mjrOJP9xRk08HuRFwTKYtVwf5wXOz7bmAQvnZPsOMfi295XKGI0eclDjvEiQKw7aqg7cym5WMG342O83nP71PJx1UcBxQOW2tgEqcUWd4ZuO/ZkWJTwawLlZ5OH2s45ugysysTlvKy1trHjb0N8+KTChmez57LfnDX3uvnXxvMA49PlI24pFlzt2Fsz7ZdJB4G1tYps3/uxiReyqfegiX4q0kdOWA5JXDc8Tyu4g+qqpgH383LyVuMc1P5e9yHOmrzoK5D9M8p8neuacbP2cbM0hBt+CB3sOvpuaJMxjZxkGTFfxvxcNfVfRDrdqp1B25dj9hst82nD6s647rNue8zZcyk55H6LzAaSxyMPtL7pIWBw450202ghwztrcbXLPyeaDPfJ3keSvJmozgPyoQDksRtpWdB1ULNJmP+zBs/byJvdf2t2WJ7YvuwjMZ9rIInXnbCx1OQb2iuZ3G5uzXBX4m2mN3/eowDE/6ag+hvb5VcX011ImXS0UKThuabtvbU0fgm+z2AhlXy+TZp+ZdbbHks4w+K5zGegiDtZ/iLs1hStlz+IuI6dxe957Sf6OW2UVXXFR9blvZTddmDZcz8o+961Ket53cSIVXJ1Rh2U8P2dJc0HigxLr5rTlslvK+U7zpo+r3+axz1nvk5vsj48HsAow73EVr7oMeMSr94ucPG56YtlpYCROIvLq6b558KoP53L8jpM+l0ODFl3ebhrPn7wxZGeT2Q0T2yL14LzFZL3qOE9eFhivtrWBynVL/cXrEulZNpz/4XjzLs7cr+lcLTIXetJxkDxvbn/SQnC86z77qsA52fex4V66Cr6tOoYfMkGn7OtJ3Knmbvy7Jk6QackTuc7oazi+u6Hi7Tr5w1WieDtFmS16iyhyLHV830nB/G1rm++20tPV4KvJgVQ4plWweHXeroLEPyRfr7R2NjAegSav7lzF8lkvux9i2V0k3a7W7NJ1Tt40Xa9/6kEerPrju/FC0JMNffJppq502h93MOk+yZl0t7FqoI6B9IMGv3vRh6BDgcnm8T79e1yxk3d8bVyhz1t5NetJOTTVVncpr63ubCXNljp7iMGmqnXopKVnbb3t2TnTVnryFibUNQ7Iu8iy6Pi5kUV30z47gHPyVU/OyVZ1EXybxUH+s7yoc9xC+1nydQVY3cuV75c8keso/NWzIF6WPUlLbtGbezx5EfVYNlXzfFrz37VV5lWCb4uultY3NPgP5+tqZebGYHGsn9fxWSN1B4oPxXmDbe1FLJ9tZXcV25d7SYe79HbQD4V6/TAnb5qu12cdDyxWD8B+ljcQW9WVhvLifo/rSt4E9boHt5mtJlrLjvrZXrT5BSdU++bD8wLn8qSpYyu4OnrMO5y+7+qLYxudNxF+1ZN2oEydnbS06vhtT/KjyEqwNhYDtDLOin36si/pKfI9NY2H8i409aWdvKp4HINsT/cYO0yTkWk7+HYdJ/GlOqjYgJwm9QbgTmo8kYt6UuWqZIkdQgpN+lpokItuWtDWxKvoCVxlAN1J8KLA6ox9vIzn67zMuRoDOb25Atx38XaWugMwT2LZLUqU3TyucHo58izvU70+7nBgsQq8lepXG7gY1PfB1SACHnFcdZ0z0Z409PXve1ReeX3wj3vm76zAZzf5HMe8z150/My9NtqrvrYBRSbSXbQJIU15Y4AHPTgn28qPedKD29xaXnGUd94s2goaFxxrnLRwvvblYtEip3ymB3BOLgqckyfJyLQZfAuZe1GhgFbbINfVSBSq1AWveBVR164qdd32U6TDrXq1alJnWdSg6PLVKsHAriYhdefh83jL877n68ukoweQdzQpCMcb8ut0x+uqgfq2sY0ou7p2reyeJOMNnj7pYb1+0EE+fOlPKw66i+wwWVgfd7WK/cVJzsRl3qMk5/U/Jw3Wp6HkQZV6lhdobeQh9vEzz/P67DF3sh3fIpXXR1/3eJOLvEDDdORlt2m8tsvfGv7+Wc+Ot+2yabSviAsRds3z5j2rj29zjmfa0DnZp3FL3jnxYzIybQbfKj/cMJ4wbQ8w6qr4z2s6YZZJPVfYpgW+q2onkTvQj4PK456V5xB3Oq1zAn8db/euWldDPR3rKqpNz8kKK6pmO16LFga/L+sI8scg09hWUVxVCUqu1es6+6FpB3lReYOAErtVFTXpYZ3J6wtmPUvvrOLx7FsX+pQP86byIK4syztvzhs4przP7PwZRiOX10a/7XHa8261HOUzlXb4+wD7oSr+0bP0NB30ORnYuTo7sPq4yc85v/fMtz3VuRz+Kqkpcl4wolzHqpSrmiPtr1s8/uuGv6PtiedJTnonFU70eYfP/KhrUhXSX9vKnrjKaJGMSxg83C3ynKyWyy6kpc6gUFMP1+9CrYGiGJyuaxA56WDV18ua8mFWYz70cYCV1z/16XbLIitMRncFecu53mQ9y2tjH9UZzCi44dfrhC7HV7O+JrzFW/2GNH5jvCYDO1fnFY9nDGaHlgdtBd9qGxgUeK5J251uEbVG2mtcLlrk2N43/B37Bjev9nzf/QbLu5NGvebVg008NHhMt8PM4kq3Ni8AFM7nOsuu4G5MQ9HEtvJDXfVV9wYBdfXvQ5wALgY2kD2EFS6NTq4LPEcr5PHjGr/ycU659WW33VEqsDvusse3nBYdmx5S8G0pL0Ytb47Xq+BrHIvtqpN/U6TjC74d9aThLysEhM5bSvu0h8e/GvRXrZB/ayHtPzaQv7MKdSDv+04q1suhN0y1D+LDZCUdwD4dQQO6eu5knWpb9dbQbUehPjwa+KS9kQs2YdVXWq8XNdXradJe8L7udmqWjFfeQP5dWgcMjXs2mWmhTMIFpcsdvw875D6r6bvydtvt4y6bY5LX9w1hJdU8Z+x7rJjlxYH4ZWB99kSRjU8rK98aeB5IK51djbcChZP9tzpfNZ2QJwXKrsjuQHt9R7ydYp/jeF+lDuSsNrpfoZ539YysaU2fc93gIH4Mzw9rYvXUcZ/zt4OVxo3UvQHU67+0PBGrs464jWc4rOqop85fJbtXK4Rbyc9rGIOeFxgjWfXWrLw+ejGAY8h77tdfFDP6OGjH7SEmusXB/kQV+WLWUEM43Tc9sQ7sO6GeNtBwz0ZQzu8H+tltaCoI9aOyG3S9ruuRAm0OGJvoPxcJYwgkUFzeLflPa/iOvM+4suqt88n8zwM4hkXFYwR9HNSkjeDbTDb31qSNyeuOlWZ7rTLLrKTct27d35LOSYWGu8sddOp6JsBcO7A9/Q1Nco4HUHaLgZddY3nTs10ei6Z5qY4cLIGa+rxM8le/nVUcN+WN0Z4rBrTPAMNxWxbsNHF8X1Rd8bPtqtp0j8/KTnb3DQpOS6azbLoGWU+bDCSM4Or83/ucuCYf+DzEANNa+t0WCd33U6NScEOaRxW+osiqt4WSABgtbfwICb7tNpEFvw8yq0xgt91at0+w630dE4ktO1jtG3xbmuCPvhMxaUXdYMhCP26lVL3ynrc23WdH6zg+yXvfa9mPuQzosxmWI1lAiQnmvsGpkw2Dy2mFdHwRAl7p54TGaZ9b98L3rwfM9t1s4Vr1KGRhENgIgV/orl8cStv73EqpesWdVa+S3TuvP9qjnuStmJsNfUXywMYtuwxhs4JJxWOEodg1J6y6kKTtcf1zz/QcJ8E3jVRR4Zlmj/f8nk1Bu+meg93ZhsnPPs9VCYG2lwXSWcR7VamWAWDfO8K+8rDkbnnA74FK+6NTuXDwwsqE8x2/PwvPky0a+IzPnj0v8J20I6/cxtD//qyYGYn5jvnlUp9NH7jttFqnO4ZGqugkY1blizasdNtnldmmNNTy3LeKmy3MxlAZ0jxoOogwGfAk29Unxjz5YrP3OW2msj9wMah2lfNnZXY+zVv1NrfqrVeGMK65r5jAnTf0g+DbbgtZ8I0qt1euT1KmNU2E9h2EHq9NnPZtlBc9uJWnrlVZjU0kWwjsHbQYPG7qs6cDzxv1mn3lBd0N5gnyVqKdF2mjY3tynvNnr2R3ewoEOidN9r8tje1mSpqRyLtgNpVFdD4vkQWt6GvHVjZoExq1sz2/68caJsOzDQOj8Ny3fY9/msmDfRvkPjzv7R81DtCaqqs6vM0WNebvVUNpHHqA4SRp7rZh9Xrc8urN/cQzPw9euACXjkNmOe3Befp6lvNR4dEeuwL64WLflRzvpB046aj/rTbJ+zrePi5wfHAIY+om5zlQrF2WBc13SCO6x7xKg3VSdcK64wrkbM/P/HHLf5fRh+e91XVL5Kbn4CU1fjbf+7nG/G1q8P9g4HncZN7UVa89N3KYY4BwMeqJbCL5uvpt1zjk0dGdOy9zHmHwqMB30E07cJLTR171NO0/5fx+4bEaHFCf/VOD8xwoxG2nO9TVIQ1gSXrR/AiN2mLPt59UnLDOGpi4Trekr6509aWzKeqswbp6lrBx4Ftj2dV+C2T8zKGX3VmDt4ee1/Q5Jj/9HQPsal8nbmMh1pVZznggtEGPd7S158nuFUqhLlpl2Y28MeZZjx9BkNd/zxQvI2qH5znjqZOxzMkZLsG3fHV0TFP58c299vvkx/sG0vTlWR1x0LRPYzzryRXDOm8ZOK87cXFSobPbbFHT5+yc2FXweAR53EgAscBkuatzmHq9zfn9T7KI6HmFupK3KcMrK5Q6UyTo2bu+Mu2jzgqMvd4qXg7sfD2XReTFB5r8cMG3diZFD0aUH1VujzqpsKvobNsvKu78NU32X/XWi1vF4oB8UdPHParzqlAMbD5NaKLubiq745rL7tFIsvpFA3lTZ70WfBvwQN6VdDLt+a6+eBKD9uvtSV6QJPTxbpXqdoyV1w486uHqt7z+e5kem9WUjM3bAZ6r9EujYzrPfMsXAixVr2h9uZ2vjl0xa7zFZd9dOkNHfbnnd/6Y7Hl7VYEgRfj9Pnlzv8JJ1qdBy7ymxuI4lm9dzyl8mlj1ljRUd7eV3cOa0nWZ1Leyq2t1582LGuv13IqWXk+8w6Y+ec98elFj3WLYnueMkUKfeLU+Gcz5zCttRC8m9Gc5fUwo2148AzIGefPGFQJvjLHPvk7r/3LH+HV1p8gzuXWwFjm//7HJL7fyrdjEuK7JWtXONHSk72p6ne/ZqOU9A2eXMHm531AZvK+Qpn1OsmV8tkCfBoZ1maZ17bKG+nqejOO2xabVuYLyrKaye5aM7zl9Z/G4qubN46Te2xZmToHee1Wgbk1lE3E30l0D+0lc6ZYd100r1j/aKde8AOjjuLtop+KqniJzDvWKQ+2zn/bhXKUzeZvdNTqeE3zL73Dresjt2abbDRroTIuqckz7ThZPkvqf91ZHmk5azIOm1J2ecCvV5b5Ls2OA4lIL0vi5uLXsKrQ1oZ0Z663CT+PxVcmbFzWnyU6n45h4v3ErC1Hes9+yK93ynhl4VcddE7Qyoe9LO1Bk1fqsZxeQoU5XRc4TffbBypszH1eJ2eQRfCumrlVFl9krniWFCV9dUfpFxU63Sn5MGjhJqj47a9JhnahrchgG53UPpELD867Mio64gcW7pP4AxZgn9lV2Ed5admk5fChZdmHF44dk/KsVH++RNyexXtedN565Mxx5AZXj2F4azGvTw8RvV7B2GtvbSZK/iva5HO2NlwX66lCmb7pKYIlV608UJyNugxcF2s4wp7ZI4DDrR5GYQWPPvBZ8q2cgVcabMrc+xWDGh6Te25xet1Bp2z5JgjbTNethVW3iFoKTOKEMr40PFg+TzRBUTl9hwPkxGdfuvm153ULZHW8pu/MYWHqX1Bfg77uyefOhoXp9peoPZhxQZOK9qledBOAyAR363x+HgX3eCuOZVW+9agOWSbFgaC2P7tjj/D9Piq1av7LqjQPwssDc/ayLc3Wtz3bBrht5F75P4l1ctRN86yawEW59+hiCcNvuOY8n5GUMZtQ5Ia5r16y2VmvMSvxtW4OJRU8HxNdJfUHi7waTydcrRKHe/haDFuH1S/pv4RUCb2eaib1dNfjZq7L7JZRXpux+i2V3mRxuwLTrvPHMnWG5KPA3rQfg4lgi1Nd3sY1+53k2vZ/4nRXoM61665l4Mb7IuHS1+vy4pTbgRVJsFU+ok1a9cQjn6rJgn13pMTt7nKvH8ft+i332auwpCNeuInewvWhiLCX4Vt9AqqxJ8vUK1YcYzPgQT76PmRPyvInJXk27ZrX1nKL3PUzTrI8VNJZrW5P5aXzpLOopu0XSziqo40zZ0W3eXFvVMrjzdJYUu3h1Evv2RutSZmX807W2OHyvZ9D1vz/eVT6ztu8yoLCHBecDjbcDcSJf5pEID+2cywG1w2FRQpHFImG+3fhFq/j5m+b3X/psJdZq3QhzriJj8Hd1t+GCb+UGUk1ehVxtRjBp8DvqWvX2ZWDYUtbPepimtz2uqnUHiWmPVQ7Km/6PBcKqkSKrrCdx0Pai7iBYnHA/S77eDn2y4/utRh5uf/xa9vV6PvCw4J+v2oHLBtqBEHAr86iP5wK6HKCw+m1RcB7+Ia4k76LPnto1vZfj8NXzfGurF4Jv5Trcl0l7tzY2UsnquuLV0EPiN33PrMTfLlsqn1mP62ibq9+ot+wWSX3BcfrNM3eG7bRE//dlghwHbpOKA/hJHMCHCff6ardtE3+67Y/3eUTHIl6Vp79lO0uK3dK2ch7bgRdV2oHMs0hDG/AiKX73Qehznik5DrQdLrpaNUn+uCutcrAlbtb1ItNn5/G4iHbrxlWJuMHTTBt+VqVuCL6Vd5EMc2XRdQwe1mnWcJpnPUzTvO9L9uMAy8R+mJ4nVi6OnWfuHN5g/jgzcAu3gz4uentLfP7rs3h7adGg28pCafWiTW/jPXQzcSsTgAvn7SoYv5rcTwtO4M/jplarZ5FOSnxvCLxdKDEO+FwNc6LTEn32JPa1v8Q++7xkn/0i9tkf4jlftM+eKa3WlYnrrNrwN7Fu/Lbh9SbvAsuRPC9/AqeZ+iQZ1vbEi5IDhKLCM9bOG0z3+z3f87jBNL0dUGPywRk7vEl92r6ESf07uTHejt4zd0YzFjiNg7AyE+HfH7Sfvj/8mG8Z+IVBXpWr4HOrp3pRTxZpOV+VGCtZ9Tas8r2K53HZOcFJfD2N799058Ykqb56VeANvu2z3yXlnlddtM+uer7O3BHRWb2oM64T6koIwN7dNta38m3PzjYZzu1hX67QNzTZa3rH01lL7+nT59fWmCTNBFxpvuxmidtPx+plfAAwIxm0pT/uJdVWGq+e97r+qhJ4C23IqRLqjTIr2TzrbZhzgjIrYTc53tAGTKrWO4E3+K7PPm2oz65yvq7aELprw+tccR7a8/NtvxR827+gniTt7E5YRRgInDYVSW/6GWv7PBi24TQth/Sw2tiY9KWOzhLLqYfavgy93PqS/lksV8Z1roZ+4V7Sj1sFv9zSnKbn1OrKXtWRRVLsYmWdm2LRbhmH8q0aiK977P9MycB35+oqAHfVk3M1LJBxR0T39SK0l3VerHiw7ReCb9UK6qLHA6VGA28tTGyrfO58YMfadB3tuoMJEw9XdPYru7myq+xhD/Jx7hw4iIHbaYd1LbTz9xp4tiv1KLIR0qsBTcBMFL9vAxYxEP+kw/wJ5/9du5rCznN1GcfYZTZPaqLPvtvA3RBDa5uXPaoXV0n1Vcy5BN+qF1ToZPu2CcM8DsLbmAS87eHnvm8oTe8HWke7DMA1edvzIbQv95Rd9UFWG53pDmFgZSXSYZyvs3jOXrQ4oL+K9esirrBqwmJgA/3epTcGQ2YFyrIvdqV12cD4crHn7/rYDnwJgCXtXpy/jhP5Jy33NfMK9air83CZk49NnTdd1OVFxfJrYlzZtz47nKttbnZ2Fc/VRla7xbZ52aMyH1R6YzD0bg1twdaYgeBbPQX1ZfDbkwodnil0r8FB+KaOrO2BX5PvHcwgomQ5XSTtPwNunrSz+nLs7ctF0v4tbaMqu9ge3u2gjQ7tseDzAY4J4oD+oqF+YxHbhNUAvum+adft0q96WARP9vxdp+lqa9xW0POWy/z1nr/raxuwjBfnf4h52UTZLjMT+Ydd1J/Yt70cWPvwqsH05gUS2q7L1znpaXsTuV3H39mjfcLK9fT1Q+yzmxgnLmL7/0PDF8qK1OPnAzsnn3dQH0JdDBft9709eWe7KPhWX0HNM8996WKiNYuT5S4GlrUvma0y6Y+NWt0N22LogYgYJG7rmSSr1T4CbzUNDJL2lsePsuziJOE0aWc1wqLD9pgetbnh+WvJ18DvkwITobxJXRhfhItrd+NkYdHScVwn36/wD//9vI/PldqR3idd7iSaedbQYkO6XvYsD8OY8uGGtDZS5vEznw+ljpWcxD2Lwfh7sf+p0rcu4mQwBNvamsjnHeOTLWV30ccNhrbUtUXM01lN44xN7fzLtoNLOem56CA911uCKat09qHPvpfps6vkzyx+xqrPftnWhdgd7ekQz8nrDtM1iwsgVoHZ6wLzsOtY5lvL+taudx/duRMy42nFtM/i4LNWadp+q+FjTptoeNK0hV0uHqevR0m57Yz3HZC/6nJAmR5vONYXdU7+Y8S5SprClsHnNaZpVNu1xzJ72kD9XMSJxPWG7wzbe08rfn6pgXj6neH73tXQAN/qSbk12bbsKrs62tuyZVdH/7Ox7GK9CG3EpOY8DJ3tqzjIXtZc9r2ty12c2wNvfyex7q3y7C/Jt7ubhn79H/GcXPTp+U0x7cdDCc73Nb1Dyse205p+30lsq+YjbwemsR1Y9UM/rvXr7zP9SsiLed9XUceyW/ZsFWfr6Y1jtWls15dxXrPo8DhDes5iXetDeiYxPcexn7vuc92O9WSS6af/tjZ+fJ8ZR/etzx5UezqUNiSeUydr4+tC5X6UULvYgIRJxLO0cM6TrztenNU8wQsT5Nc9OcHrTsP7mj7jvGdp6lMdfZnWzatYL5/WEIRYxMnzlRag+bYlLbtw9TwE4X6qoew6D+B3kI+hzbob2+dH6x3onvU/3E7x0i2mFKh/i1hnZgNNu/QeUD62ndZDWTE/xk0RhlZ2TaU3jgOuk/rvDKqSnqse5XtoU14OrJ7M+1KezsnenFN7teF5wbc6OoamOu3nPU5btnBCY3eVuQpyP070piU+ZnXVKwSAZn3rsMOJkh5fnfdk19G4zZJ67xMfXINbojO+ilcazmL9nJbI41Anr3vcWC6Sfj7foI6ye5Z8DcSFsvupZLtStuye13RO9i0fV/V/Euv/g5J5GPLudUv1v891+XVS/QLF6CaiAACwcksWdGfTksUNk0MTErqom5Nk+4qqxT5XwtPP/JhUX6V1MLemVSi70KYc11l2HR1HKOdGbjutWP+XnmUIAACUmmPIgu5UWbIIDdfNRVL/ytCJnG2l7ASG+ln/AQCAA2W3U6BxcZUnAAAAHBzBN6ANJzV9zkxWAgAAMCSCb0AbHsgCAAAADpFnvsFYTuZ6HlAfdr982EDyzur4EBuQAAAAMDRWvgFZZ3U/ny39vGlSz2YLC8UDAADA0Ai+wXjMavqcy5rTddmz4wMAAIDWCL7BeMxr+pyw+u28jg9KPycE3iY1peu9IgYAAGBoBN9gJD7d3CyT+gJwl0d37jyu8gEx8HZe4yFeK2UAAACGRvANxuV1jZ/14ujOnXfxmW2Fhb9PXx+SmgNvMbgIAAAAg2K3UxiXsDrsRY2fNw2vozt3woq6t8nX564tPt3cLH5vRL5u0HASXz/Fn3V7q2gBAAAYoluyAMYlrFZLvgbNxmL56ebmByV7cPX4WfrjadXPSeuOfg5gmP3AJPn63Ni51e975d800xfO5AhAx+2yLIDReZ6MK/j2SpHS0cQlrOIsspI0TArDhiDX2VWhALEtCSvEw3NQw88naTsxlytb82qSfL3wchbza/XvoW19nubdlVzamnchz36KY8Djtd+t+qpwh8TbNB89RxdtsjaZllkRAOPsVMay+i0MFO+64n2QdfhZ0vHKtz3T8DJOENVZYNWWhP74Xfzf0D48kysb8+kk5tPxjj8Lk+RTbew3+RaCbuFC0aTE2xbp68KKOLTJh9Umx8BjOPaTOM86FXxsjw0XYJwuxnIcBtgMTNgl+F0c3ABQbEI4Sb4NvC3S15P09TD5elFjNRYIE8ZLOfZ1Ep2+3qT/GV6TtV+HyfQs81qfXE9iXyUvod3z9iSct+Hc62iseJb88Xzu8P2PlEp7BN9ghOKtb08GfhjXbougR8KV0Vvrr/Tf7yZfg92zzN+uVm8AUMyj5I/A21XavoZV7y/DOCB9PYlt7WI1eYyr5A55Ar9avXKW+ecQoAyPHgl5dy99nWZe99J//yH2V4vMe87Tz3qs+kFrzuLrPGlmk7o8FjV0SPANRioMWsMAdqDJXybjWb3HuM+zsPtvmCieJt8GvMOVzXM5BFDINNP/P9nQ1q4CS9kJ7EFau21sJYz5QtDt2bZnj4Y8jP3V3fj3KwvVDw5m3HqdmR/OkuEv1hgUwTcYt9CgDu0+/tXzB1yZYWgDmpdrk8OncgWgkFUgadfOplbDf3WZfBt4C4/oeFJm3BRXE4bVcPfcZQAHN169iHdwmG+1TPANxt24fglkJcMJwHnwJ0OXfTbR5NBvjQIoaLFqN3f8zeTQMylurpBd9Xex7w6wYaxlvAXQHsE3GLlMAK7vVzYF3hjL+XZtsghQyqrvn8SdCDfJBp0WB5pPLzL/fbVv4A2A9h3JAjiYgMDD+FDdFz0ddF8IvDESP2f+O6x8ay3wHVfahQnq/Q3n2Nv0HJt1NuD4upvh+Ya0hUn0++TrJivLDtMX8u1B8n3A9G1MW6eT/b7mX6xz4Rbrv4fnTcV/O45pfbCel/H27LbS9VPy/QOtw7nwug/9TQwy/ZRs3qmy0/O1A6+SP4JrYRfAe9n6HOvUale+ZXKAt6DGNmqSyYMnAz2O40w/tV73Q1t21VV7m6YttGF/C3m7qn99P0/71Ddk+oPXZW9nzrz3fVv9xKGqUk4V269wHj1f9b87+ulFPLeue5Jfk0ybld2hdpk5xxZqFrCxwU1fYXv533ryetHRVtv0u54+q6N+1ZiGZyXe9yLzvvO2BgYFz+sPbd8KG87v9HVZIG2/dLHrXhgQpq+PBdJ32UVbVaJsfylTT2tMXzZtXzYaiWnZls5pT/q4d22dC+GYs21JH9PYk3b/3VpbdZxpQz7s0x6PLH/eDDkPYjk+y2kfsnV/0nL6BnWe9rFvzeZX1b6kzbJuuW3LK6uzPpdThXFM9nw5XmvPtr0+Nj1mqOkc+y0eT26b5bZTODDxGR/hNtT17ebbNku+3mb6xMM+GZlWb42Kg9QPyR+7BWa/e311z5e/bXkn1rAr3/mGtM3W/i1MtEPg8rLFgVVYCfwm2byiYb3swjG8azMAF8tpU9luEtL1NBu06EC4kn6ZfHtlOGvZ5DlRMr+msTzbnjQ/iOdEn9PYlYeZNuskHvsk+XZnz6vVCssDlK0zV0NKeKYcn+5oH9aP9UMbgYgBn6e97VtrcDziczfvuMfY3k/W/vtjUmzH6kk8t87bTnA8nz9uOMd2jf1zL3ALvsGBymw3Hwa7bS7rDYOC07jDzkxJMCbrtwU1XcdjJ/8uM1ANA+8QWP8hnN/pK9y6dWttUhtctjFRiFfbs9/zPJO205i207XJwnlLV35D2h5vaJtuxXwL7eMPMc3LbECgpboUBuvZQNYypuVuTOOtTNlm2/BV0KKLycvZhnp4K/P6oalbMzL5lWxLQyzP7IWn4w4mzSeZMg0BlIdr5Rl2oHy5NhlrfRVQR+OS9U2iVpOfbODt4kD7lmy9WQzpFqfYFr1Z6wtC3b+3VvfvrrW3X97X0cqXIufpVVfnaQxG7NO3nid04Uksi1ny7QWoeebfZ7FOXY08LyaZc2sWxzA/7GgHVmPW1tqBDWPrJPbLRdqsdzZbA4o0NGFJ8OOCy4DLvj7Ez57IaQrWx8HddhpvUcneTnPZQj5tvE1rx99nl89/aDl9j0uk7byF9u63EmlbL9tnDafveO37ipTt+fot/S2dq+u301x20F4cr906vPMW4Q23vDRdntOytxZ10Z70KViz4dbEgzn+AnXo3cDS/mat7k8LlP+Htfcct5zHvT5Pe9y31nXb6bTFsn7W8vnwrK3jbKKcajq3itTb9XbgY4v5s97+nBRoBz6s3S67sc2y8g34IlxFDQ84TV8PM1fMwpWaEOmfJd/fvrZN+NuwCiNcCVhdzbgXP3shpxnhpGgSB9whmJVdpfSk4e8Ng7Zp5vtO827hjqtGfl9V0uYtPXkPUI5puxeP46rh5DzN/PdVgbTNY5u48qjh9L3I1KV5wbINeZZdFdTFBY9FRyuTwiB+ksmvnY8zCL8LfV3s366Sb1eateF53oOkY517mPmn80O4gBUnLNn6n2TaK8+H/er9gMoz9FHZfib3rofMCsjVmPE4+XaVsvO0v30rFPGyQL1dxnNr1ZdPWror4jz5Y1Xpamw9LzhG/D2t29oswTdgW0MyiwGzJ3EJ+72124e2vU5jAO9ZGLR4nhsj8VO8Urj+ClcN158JUSgQVoNsAKjMsxOfZ/77QYuTsPMC7c68pdvRzzNlVShIGgdXq4nLcVODwMxOgKXLNk6srrfUkVYmq12dn3vmV/jbi5b7qUXRnfziuZA9H6ZjbmRj3c8+x2qefP8MOAG4JPnLkPrOtQn3vGDdD+fkRYdtWdnzdN7VedqzvhVqGyvERRtXmX+630Lasm3N85Jt1pMtbd/vBN8AIN8kDqjXX+vC4Pa0aGdd0TTT6V8VfdPalfymJwlvM//9It5+3unkee02j7IXCLLHc9Jguf6+6m2PCVN2UNv2w8oXHZTnJPlj1dtiABPMsul7v9YOjVIm8Pb7892SrysJ1p8B9y7nluJpMn5Dep5Qtg16VeaN8VxetSnHLZdt2fP0bcvn6eu+9a1Q0LyH465sP7T+bMoybVb4++xKve/agiPlDwC1eFL0SnlNfn/49h7PLFnECUKjk4SQH2nafkr+eHj1izhRmMWgwjwOxBYt5lt2AjcpmXd/y/z3jy1MrN/ukefz9JiWMb8nB3DeZY9xPoD0/rxHEOBpw3WuD9Z3NL3ITIhOM79fBeC+WV2cDd6l/z3GjRkWW+p8b8WJZ/ZCwj7tfLhY9DjTNs6cp18n+bFvnfaob4Uiyq40b7MOZ8dfsz1XxYdz8CzTVn+TfsE3AMgXlp4/2zC5eJf8EcwJA+FWgm9rKwAmybfPMOuVcMt6fPh/9vkX00y+heMJg5NwJf9ly7cAfpOOktpYZbDvRHO+Oq7wIOCWVmL2wd9HfnyjXNkS24eTzITnYq0NWRYIwF1mPmN0+RSCKNmgeghsDSCwMqkw4V75xwDr/3FLdeK0x30r1Nn2dfHV+z5bM4xDzjLn4zfjOLedAsD+ss93OMnbvamHWgnKhGdrJV+3ZH+SbA4ohUlaCCB+HNAW7UN56LlbkeituDpq1W6uHrC9qQ1ZPYT/u1tQ44Y3Z5k27WKk2dXl8xzpoZH2rTBagm8AsP/AN0z0ss/YetrSTmfZoNms4GYom173Wsyr1Y7Kp3FH5XtxknyV+bPjOKFua5JwUSHvnrWQvume7zvUSdbftEqDk30m2FXeLrXJ9wG47IY3y3hOj3WFT/Y5X+cDeMbXYq1tp52+9W4P+tZEsI+B23dzh523nQu+AUA1LzOTjNWzV5oebC+TP27jGeQAN+6+tno2093MhDrkYZOrOmY1DK6aNC86iNsx4TmkiW52gj/VHA1Oto6/LdBurAfgVnV9tcv0aG+xXtv9Nhz3Zc/Tu8j2U3sGCx9sabvZke87+tY2H1Eh4CqPhibbf+w7tt75PsE3AKg20P2y2iLzT2fpJKONXSZXtyCF267Ohz5ZSL693eyswe+arZVV3wa/6+mblHz/owM7/0LdWcT/nRzIbpdjMtmjzJfJ94GYbD0Ys+dr7UPf2/5sOZV6LEM8l1cT2eUAdjIeQt/adPuYDV48KFHWx8lhXjyxOrB/4/n5vmPr+Pc7+zTBNwCo3mGHScFV5p9etBDUed3y95UWVmEVvfVk7eHhTR/LVeZ7LntWl5ZrdemyRH6Hycv5AZ6Cr7L5NYDb8fhD6fM+TnAeb5jEvht72ce+5uVafd/rnA/va+E5pdlz82nR/iCWY3YV+bVTZRB9a/ZZqGVuje7yeblt7yK97PC7aWhsHf8ud2Wp4BsA1ONJZlA1SRq+vWPDLUiFJp5hshUeUN70JDWu/vsQXkUmh2srlpq+dex5pqzO4gPb89IXVlW9aGlTjezqlmmR8or59+ZAz72rJLP6rci5ECevb9LXM01Xp7KT9acFzsNwrmbP14tkwyYMY86w+JD9bBt5Gety0UliaMvexHxstE1b66eSpMBzx+JxvEkyq97W2sSDtta3Pi7w9631rWl5XyffPoajSFt8nrS/Y/tyrY9ts83IBpLPhn7nwsjHE0Xr8Je/Swqs5BZ8A4B6Bp1hMJfd/fRxCw8cvki+ffZb2NHs2aaBQlzlEB5OHlYThMFe00Gkk7XJ4btNt+PG3QofJ98Gjt42XFaLtbIKefNhS/omMUDzIebZi6bLNaYveyvzeZxofbeSIKbvMg78jjdMLA7l3Hu4Vvd25dezmF+hvJ96MHinrpNvnwv2ZtOt1iGAEM7R5NuVnWFzhTBR2rgL6sjz7XQtkHIW2/+t7VMMOF/GtuysxbRm+6njeG4+Wy/n2Becx/RNM796srZ669Bl8+1Fn/rWVXkVbItPMkHgtvuM+VqA5TK2MdMWvjt872xtfPRi9f0tbdrF7vHExVod3ji2zrRZHzNj3tmuz78liwHomzg5rnwlNO78VUcanhfd3TIMhDMTh7AT6WnDeXWSfBt4WZlnJjzrA8ovwYomn6GTuRK4aSI4ywx6138/b2sX1jhoutyRvkny/ZXMkK+nbeyouCN9q7LdlL4waPwpU+anDZfzu7a+q0BazmJ+HZfIr8brW5zQvSvblmx4b+PtSUfltqmez+LkeNVGTNbar282V9jQ3lynv394AH1luJiy6UJK9tlFm/qAldWD+ZtO57Z+arFWzutWAdY28nIQ5+nA+9ZlLO+TDf++zJznjfclsb/YtFr8ZVxd2uR3h+P8kGy/DfhukwHnbL9dZZzc1vmRvv+3tvvAHXV4V5t1kXx758t37YiVbwCQr8wg6KLAhKc2cQIadjRbn6CcxO+fbhicNz6wDcGpONDP3uKZzZfphoFLeJZRa8GFzKqZxZb0rU/4nyctBd5y0neyIX2LmLarCnV30OItT6fJ91eeN+VX6/WtBsuRlttV8u3qqNU5GCY/Z2vlNosT0/l6e5N8vxrsEOr8ky11/jjTjk239GkP2wi85fRTky19QTiee20F3oZ0ng6ob324IX3HW8p6vZ9btpDG6w31MUla2AQhBtZ2tVeTAx5D96lfurehjDa1Wav2NLznb5l//658rXwDoHfiFaefaug8TyukIXSwL+Ig8EmZgEsm/e/LXD2vId8mccJ6P/ljlc9qBUR4ttJVF7fvxCv1Z5l0ncRB+CK+OktbJo0hfQ/W0re6NSXcqnPdVtBtR526nxn4rSYtX9IXJxLZY3nURv2LV7TDVd5506sF9kjXg1iW6/VtVZ6LFuv/i5iG5+uBowLvv9z3vQNr949j+/Ug+TZgtIh1/XXeRYP4GSeHuDNmXF3205bgy2oiOF9vLzpI565+apW+WUf1b1Dnad/71kz6Vm3xZK0u/n5OZ/qStsdN03jerNL2pM12dm3s8aW9azoo3uYYIfOdz2I9fVW2/any3gbqyDRTh1fjr6vM337MlOW9MffZAAAAANCa+My+3+Lrl01/47ZTAAAAAA5a3ADj3R6bMWWfVX0tJwEAAAAgI+7C+/vqtaIBuHDbeeZ9v9m1FgAAAAA2OLpz58NaAO5ZfH7hpr89Tl9v1gJvj7d9tg0XAAAAADhoMdD2Lvl245qwKcwsff09828/Jl83FMm6amsXaQAAAAAYpLii7cXaira81+O8z/2TrAUAAADg0P36+fM/09d/vX109D7+0yR9/XnDn4YVcf93+nr46ebm/8n7XLedAgAAAMAGcfOF7LPflp9ubuZyBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGLX/X4ABADdvGiZHZ1RtAAAAAElFTkSuQmCC" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/lucy-schick/fish_passage_skeena_2025_permit/raw/main/mapping/sites_skeena_2025.zip">here</a> or <a href="https://github.com/lucy-schick/fish_passage_skeena_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Trust Conservation Foundation, Ministry of Transportation and Infrastructure and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from the Office of Wet’suwet’en (contact Julia Onderwater - <a href="mailto:Julia.Onderwater@wetsuweten.com" class="email">Julia.Onderwater@wetsuweten.com</a> or Dave Dewit - <a href="mailto:david.dewit@wetsuweten.com" class="email">david.dewit@wetsuweten.com</a>), Gitskan Watershed Authorities (contact Alicia Fernando - <a href="mailto:afernando@gitksanwatershed.com" class="email">afernando@gitksanwatershed.com</a> ) and Gitsxan Environmental Services (contact Chaz Ware - <a href="mailto:chaz.ware@gitxsanbusiness.com" class="email">chaz.ware@gitxsanbusiness.com</a> ). Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, cutthrout trout, and dolly varden. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<!-- ![signature](/Users/airvine/Projects/current/Admin/Al_Sig.jpg){width=50%} -->
<p>Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
460-517700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
641633
</td>
<td style="text-align:right;">
6049398
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
460-636000-36664-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
654312
</td>
<td style="text-align:right;">
6012383
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
460-185400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
605786
</td>
<td style="text-align:right;">
6099884
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
460-600600-07100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
643460
</td>
<td style="text-align:right;">
6025890
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
460-600600-36400-26300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
623369
</td>
<td style="text-align:right;">
6000283
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
400-448500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
582874
</td>
<td style="text-align:right;">
6130541
</td>
<td style="text-align:left;">
KISP
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
CT;DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
DV
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Bulkley
</th>
<th style="text-align:left;">
Kispiox
</th>
<th style="text-align:left;">
Kalum
</th>
<th style="text-align:left;">
Morice
</th>
<th style="text-align:left;">
Zymoetz
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus sardinella
</td>
<td style="text-align:left;">
Least Cisco
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Entosphenus tridentatus
</td>
<td style="text-align:left;">
Pacific Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Gasterosteus aculeatus
</td>
<td style="text-align:left;">
Threespine Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lampetra ayresii
</td>
<td style="text-align:left;">
River Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout (Anadromous)
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii clarkii
</td>
<td style="text-align:left;">
Coastal Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus keta
</td>
<td style="text-align:left;">
Chum Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Summer-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Winter-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
E/T/SC/DD/NAR (Nov 2020)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii pop. 3
</td>
<td style="text-align:left;">
Giant Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Pungitius pungitius
</td>
<td style="text-align:left;">
Ninespine Stickleback
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Cutthroat/Rainbow cross
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Verified DV BT hybrid
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
