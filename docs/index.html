<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_fraser_2024","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_fraser_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/raw/main/mapping/sites_fraser_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Conservation Trust Foundation, Society for Ecosystem Restoration Northern BC, and the Ministry of Transportation and Infrastructure (MoTI). Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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oRBEa6LcnoFB853oAw0U14IGz2LsGHV+pzpyY/z5zxkykOb3J9Vv6jHDY33ED5/FlVMsBb4yj+f9Hz3hP643K4hSg/H7k08iDvgfCLWpdWOQ10F6mLZU53Hj85l/sYxzL7yX4bomqzmA40kywwie69/ExBvhyJxtShAfPjPReTrglz4G9R2QeEm/I0ZAGqSIZXhYkss1RNnsBmLSxom6YVi23lMc9x7vrvvmt63236uftSGDh9lZM+d2NxhojbrG/ETi3O1I6sa0Ejje7svBPRX2/DNr7frrr7f/mH9xWuPwLw1sSOvQh2DKqlz2EahqqrIXVq+zefPm2X9d/p/ZF0HFSAREoEsEEoaRunSfPIuACIiACIiACIiACIiACIhA6AhIQApdlipBIiACIiACIiACIiACIiAC3SUgAam75HSfCIiACIiACIiACIiACIhA6AjISEPoslQJEoGeRYCWBA8dOuQL0RPNr/esVCi22UyAe6BVV1cbrV1m+/rFbOaouLVPgMYPqqqq3AIqN3eVEwER6NkEJCD17PxT7EVABERABERABERABERABNJIQFPs0ghTQYmACIiACIiACIiACIiACPRsAhKQenb+KfYiIAIiIAIiIAIiIAIiIAJpJJD7V7g0hqegREAERKBdAty896WXXrKJEyda6nqj33//3d577z3buXOnDRgwwPr1w1b2bbh9+/bZq6++aqeeeqpvVNuGF52KMIGOyhg3mP7ss89sy5Yt2PC40UaMGJFEqrPrSZ51EGkCn3/+ue3fv7/LZYjlbtu2bfbxxx8b11+OGjUq0hyVeBHIVgISkLI1ZxQvEQghgaefftoFpEsvvTRJALr33nuN17i4eevWrfb888/blClTbMyYMUkUuBD6vvvus3fffdeuu+46y83NTbquAxFor4x98MEHdsstt9jBgwf9s27dOqOwPWvWLIfW2XWRFYGAwPbt2+3OO++0sWPH+kBNcL6zMkThaOnSpfb2229baWmpvfzyy1ZeXm5nn312EIS+RUAEsoRAXpbEQ9EQAREIMYGKigp7/PHH7ZtvvmmVyp9++sk4Grtp0yYbOnSoX7///vtt1apVrToOr732mv3444+twtAJEeiojB07dsxefPFF75wuWrTIYbHM3X333XbZZZe5RrOj65MmTRJgETBaQ6QGnJ+cnJwkIp2VMZahjRs3usXODRs2uNXOsrIyH+i5+OKLberUqUnh6UAERCCzBLQGKbP89XQRiASBRx55xKj9efTRR1ull6Zxb7zxxrhwRA/Tp0/3kVXeE7jdu3d7J/emm24KTulbBOIEOipjnAp15pln2vz58+P+WcboOLWzs+vxm/Qj0gQ4BZja64cffriVdvt4yhCndrIMFhcXO8dx48bZKaecYh9++GGkuSrxIpCNBKRBysZcUZxEIGQE7rrrLhs2bJhxxDTVzZw50/hJdJyff/LJJ8dHaRsaGoxapcWLF2vOfiIo/Y4T6KiMDR482JYtWxb3yx8sY5yiyZH7zq4n3aiDyBKYPXu2XXTRRZaXl2fPPPNMEofjKUN79+61kSNHJt3H4z/++CPpnA5EQAQyT0AapMzngWIgAqEnQOHoeB2nn3z77bd26623xm9Zu3ata5gWLlwYP6cfIpBIoCtlbNeuXbZmzRq75pprXHBPDIe/O7ue6l/H0SAwaNAgF46OJ7WpZYjT87jmraSkJOl2HlP7JCcCIpBdBKRByq78UGxEoEcTeOedd3yOfZAIru8oKioKDjv9Xr9+vb3yyiu2YsWK+Jx8rlt6//33fXpdpwHIQ+gJnGgZ++6774zapvPOO8+ndqYC6+x6qn8dh48AB2h27NgRT9gZZ5xhkydPjh939qOtMkRtZa9evXwdU+L9FJyCKXeJ5/VbBEQgswQkIGWWv54uAqEi8NFHHyVNF7nggguOS0DiAueVK1ca76cxh2B9COFwpL9Pnz7x9Uu0QkZ3zz332IIFC2zu3Ll+rD/RINDdMkY6XAOyfPlyu+KKK2zJkiWtgHV2vdUNOhFKAjQEQ0tzgaPFueMVkNorQzTqMHDgQKupqQmC9e/q6mobPnx40jkdiIAIZJ6ABKTM54FiIAKhIfDEE090Ky0PPvigT6tbvXq1WxRLDIQWnmjIIXBcVP/DDz/YtGnTvMMRnNd3NAh0t4x98sknxnLGqZs0M5/qOrue6l/H4SVw9dVXGz9ddZ2VIe7/xrqLdVrgKIxdfvnlwaG+RUAEsoSABKQsyQhFQwSiSoDT56gVuOOOO3x0ldNbAkcLT6nrjr7++mvfUPbaa6+1goKCwKu+RaBdApWVlUYrd/PmzbPx48e7MB545l5btJbY0XWO/MuJQEcEOitjLEMUhLiP2yWXXOJGaN544w3fLJaGH+REQASyi4AEpOzKD8VGBCJHgHsb0T322GOt0r5582afXtfqgk6IQBcIUAivra11c8qpJpW5Hokayo6uJ474d+Gx8hohAp2VMZYhWuu86qqr7Oabb7b8/Hy3yMmpwtwgW04ERCC7CORg5Kxlo5HsiptiIwIiIAIiIAIiIAKhIlBfX29ce0TT4HIiIALZSUACUnbmi2IlAiIgAiIgAiIgAiIgAiKQAQLaBykD0PVIERABERABERABERABERCB7CQgASk780WxEgEREAEREAEREAEREAERyAABCUgZgK5HioAIiIAIiIAIiIAIiIAIZCcBCUjZmS+KlQiIgAiIgAiIgAiIgAiIQAYISEDKAHQ9UgREQAREQAREQAREQAREIDsJSEDKznxRrERABERABDogwH2LysrK7MiRIx340iUREAEREAER6DoBCUhdZ6Y7REAEREAEMkyAG3OOHz/ePv300wzHRI8XAREQAREIGwEJSGHLUaVHBERABERABERABERABESg2wQkIHUbnW4UAREQAREQAREQAREQAREIG4G8sCVI6REBERABEYguga1bt9qGDRts9+7dPgXvwgsvtPPPPz8JyLPPPmulpaV27rnn2gsvvGBfffWVjRgxwhYtWmSzZs1K8qsDERABERCB6BGQBil6ea4Ui4AIiEAoCTz00EM2Y8YMe/PNNy03N9c2b95s8+fPt6VLlyald926dbZq1SqbM2eOPfDAA1ZeXm5r1661c845x15//fUkvzoQAREQARGIHgEJSNHLc6VYBERABEJH4Msvv7Tly5fblVdeaTt37rSNGzfa999/b8uWLbM1a9a4Vikx0Vu2bLGFCxdaRUWFG3rYtm2b9e7d21auXJnoTb9FQAREQAQiSEACUgQzXUkWAREQgbARWL9+vWuNnnzyScvPz/fk5eTk2IoVK2zo0KH21FNPJSW5sLDQqHGiUEQ3efJkO+2009x0eJJHHYiACIiACESOgASkyGW5EiwCIiAC4SOwY8cOGzdunAtDiakrKipywYdapUQ3ZswYKygoSDzl9x4+fDjpnA5EQAREQASiR0ACUvTyXCkWAREQgdARqKystJKSkjbT1bdvX2toaEi61qdPn6RjHlDj1NTU1Oq8ToiACIiACESLgASkaOW3UisCIiACoSRw0kkntTs9bs+ePXb66aeHMt1KlAiIgAiIQPoJSEBKP1OFKAIiIAIi8G8mMHv2bKMW6a233kp6Mo0vbN++3aZPn550XgciIAIiIAIi0B4BCUjtkdF5ERABERCBHkPgtttu8zVIN9xwgz333HPGNUmbNm2yBQsW2IQJE+z222/vMWlRREVABERABDJLQBvFZpa/ni4CIiACIpAGArRG98UXX9iSJUts8eLFduzYMSsuLra5c+e6me/Ro0en4SkKQgREQAREIAoEcrAgVStSo5DTSqMIiIAIRIQALdFx3dGkSZPiJr8jknQlUwREQAREIA0EJCClAaKCEAEREAEREAEREAEREAERCAcBrUEKRz4qFSIgAiIgAiIgAiIgAiIgAmkgIAEpDRAVhAiIgAiIgAiIgAiIgAiIQDgISEAKRz4qFSIgAiIgAiIgAiIgAiIgAmkgIAEpDRAVhAiIgAiIgAiIgAiIgAiIQDgISEAKRz4qFSIgAiIgAiIgAiIgAiIgAmkgIAEpDRAVhAiIgAiIgAiIgAiIgAiIQDgISEAKRz4qFSIgAiIgAiIgAiIgAiIgAmkgIAEpDRAVhAiIgAiIgAiIgAiIgAiIQDgISEAKRz4qFSIgAiIgAiIgAiIgAiIgAmkgIAEpDRAVhAiIgAiIgAiIgAiIgAiIQDgI/D9WOVjWcRg+zwAAAABJRU5ErkJggg==" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-03100-20600-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515409
</td>
<td style="text-align:right;">
5989806
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-593800-25800-29500-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
496209
</td>
<td style="text-align:right;">
5999657
</td>
<td style="text-align:left;">
LSAL
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
100-596500-54900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
583374
</td>
<td style="text-align:right;">
5911978
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
100-596500-03300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
537250
</td>
<td style="text-align:right;">
5991350
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
551588
</td>
<td style="text-align:right;">
5970657
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
100-574400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526285
</td>
<td style="text-align:right;">
5978523
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522679
</td>
<td style="text-align:right;">
5956610
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518502
</td>
<td style="text-align:right;">
5962002
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
524160
</td>
<td style="text-align:right;">
5957999
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
100-560100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521127
</td>
<td style="text-align:right;">
5965112
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
100-567900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
516996
</td>
<td style="text-align:right;">
5972733
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
100-562800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
515025
</td>
<td style="text-align:right;">
5966533
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
100-596500-82000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
573972
</td>
<td style="text-align:right;">
5894796
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
100-596500-90900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
590481
</td>
<td style="text-align:right;">
5882133
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-535900-08600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
517279
</td>
<td style="text-align:right;">
5936628
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
100-559300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
518845
</td>
<td style="text-align:right;">
5961982
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521864
</td>
<td style="text-align:right;">
5976392
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-587900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
526448
</td>
<td style="text-align:right;">
5985791
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
100-580500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
522978
</td>
<td style="text-align:right;">
5980978
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
100-536400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
520105
</td>
<td style="text-align:right;">
5935908
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388945
</td>
<td style="text-align:right;">
5997015
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388276
</td>
<td style="text-align:right;">
5996951
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
398947
</td>
<td style="text-align:right;">
5996427
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650784
</td>
<td style="text-align:right;">
5934858
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587921
</td>
<td style="text-align:right;">
5972449
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965784
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344022
</td>
<td style="text-align:right;">
5862734
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
100-596500-84300-21000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577020
</td>
<td style="text-align:right;">
5886032
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
100-596500-10600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
536470
</td>
<td style="text-align:right;">
5981315
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541465
</td>
<td style="text-align:right;">
5981577
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
100-596500-11100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
541358
</td>
<td style="text-align:right;">
5981709
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
100-553400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521645
</td>
<td style="text-align:right;">
5955176
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
100-545900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521513
</td>
<td style="text-align:right;">
5949553
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
100-596500-15700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
556416
</td>
<td style="text-align:right;">
5962053
</td>
<td style="text-align:left;">
WILL
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388738
</td>
<td style="text-align:right;">
5997154
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
12200024
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
BB;C;EB;LKC;LNC;LSU;NSC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
12202167
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126267
</td>
<td style="text-align:left;">
Stephanie Cr.
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126290
</td>
<td style="text-align:left;">
Hay Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;CAS;CC;CH;CSU;DV;LDC;LKC;LSU;MW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
126316
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196051
</td>
<td style="text-align:left;">
Unnamed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196072
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196085
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196151
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196201
</td>
<td style="text-align:left;">
Haggith Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196207
</td>
<td style="text-align:left;">
Hudson Bay Slough
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196264
</td>
<td style="text-align:left;">
Parkridge Creek
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196328
</td>
<td style="text-align:left;">
Archer Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
196340
</td>
<td style="text-align:left;">
Slough Creek
</td>
<td style="text-align:left;">
BB;CCG;LKC;RB;SP;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19702777
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703257
</td>
<td style="text-align:left;">
Tabor Creek
</td>
<td style="text-align:left;">
BB;C;CSU;DV;EB;LKC;LSU;MW;NSC;PCC;RB;RSC;SB;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703286
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CSU;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703295
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703303
</td>
<td style="text-align:left;">
Bertschi Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
19703358
</td>
<td style="text-align:left;">
Trapping Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199171
</td>
<td style="text-align:left;">
Tributary To Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199172
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199173
</td>
<td style="text-align:left;">
Tributary To Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199190
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199237
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199260
</td>
<td style="text-align:left;">
Tributary To Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199267
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
199278
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24400646
</td>
<td style="text-align:left;">
Rucheon Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401504
</td>
<td style="text-align:left;">
Tsadestsa Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24401692
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24402183
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723694
</td>
<td style="text-align:left;">
Cale Creek
</td>
<td style="text-align:left;">
CSU;EB;LNC;LSU;MW;NSC;PCC;RB;RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24723695
</td>
<td style="text-align:left;">
Red Rock Creek
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24727190
</td>
<td style="text-align:left;">
Wansa Creek
</td>
<td style="text-align:left;">
CBC;CH;CT;DV;RB;RSC;SP;SU;WF
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
7622
</td>
<td style="text-align:left;">
Unn Flows Into Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Lower Salmon
</th>
<th style="text-align:left;">
Morkill
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Tabor
</th>
<th style="text-align:left;">
Upper Fraser
</th>
<th style="text-align:left;">
Willow
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus platyrhynchus
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
E/T/SC (Dec 2018)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
