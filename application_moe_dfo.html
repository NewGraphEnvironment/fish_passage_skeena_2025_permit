<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_skeena_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.com/fish_passage_skeena_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.com/fish_passage_skeena_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-08-05</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit/raw/main/mapping/sites_skeena_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Trust Conservation Foundation, Ministry of Transportation and Infrastructure and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from the Office of Wet’suwet’en (contact Julia Onderwater - <a href="mailto:Julia.Onderwater@wetsuweten.com" class="email">Julia.Onderwater@wetsuweten.com</a> or Dave Dewit - <a href="mailto:david.dewit@wetsuweten.com" class="email">david.dewit@wetsuweten.com</a>), Gitskan Watershed Authorities (contact Alicia Fernando - <a href="mailto:afernando@gitksanwatershed.com" class="email">afernando@gitksanwatershed.com</a> ) and Gitsxan Environmental Services (contact Chaz Ware - <a href="mailto:chaz.ware@gitxsanbusiness.com" class="email">chaz.ware@gitxsanbusiness.com</a> ). Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, cutthrout trout, and dolly varden. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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8UVzcOa+/vPCReByc0z+lI888og9/vjjLtltU1PTLKCGhobsJz/5ie3cudOqqqqsvNwn4pwFkP8yjcCjjz7qnocXzqErzbHpCvjwzW9+090Hq6urZ272nz0CV4WAJ0hXBZPfySPw0yEgJ/kPf/jDdurUKXvLW84nUlStWqP4p3/6JycsSID94Q9/aK997Wudw7N+l8D7h3/4h87J/umnn3YZ6++66y4Lh8P62RePwDQCf//3f+/my1vf+tZZBEjzR7/JuXn79u1uvq1atcpaWlrcsSJGv/Zrv2bDw8N29uxZ+7u/+zsnwGofXzwCMxF4oTn2gx/8wH7913/dzSHNoy984QvW19dn27Ztc4drEUhzrLOz00TG//Zv/9YmJiZs06ZNM6v3nz0CtmfPHvud3/kdW7JkiW3YsGEakSvNsekd+fDv//7v9jd/8ze2bt06W7Fixcyf/GePwFUhUHxVe/mdPAIegReNwDPPPGN/+Zd/aVo9Xbp06ax69u7daw8//LB97WtfM62UKeLY29/+dqctes973mPSHIk8ffKTn7SNGzeaokV96EMfsq9//evufVZl/suCRaC7u9v++q//2nbt2nURBocPHzatxmo1tb6+3v3+R3/0R/apT33Kbr31Vvf985//vN1zzz3227/92+77P/7jPzpC9aY3vckKCgouqtNvWHgIXG6Oiej88z//s7snvetd73LgaM79/u//vr3tbW9zAupnPvMZu/HGG+1P//RP3e9a7PnoRz9q73znO2eR+YWHrO9xHgE937QgqNeF952rmWP5etrb2+1zn/uc14LnAfHvLwoB74P0omDzB3kErg6BeDxuv/d7v2f333+//eIv/uJFB9XW1tpf/MVfOHKkH4uLi50mSaZ2Ks8++6wtWrTIkSN91+9veMMbnJZJ333xCAiBP//zP3dhcDWXLiwKjfsrv/Ir0+RIv2vVvquryx2j7yLmefKk79IsZbNZR8j13RePwOXmmO5Xt9xyi917773TQOU1QzLt1EsLRVrcyZetW7e6xR+FBvfFIyAEZEHxn//5n45E57XbeWSuNMfy+4lk/cmf/Im9733vc1YWFxKt/H7+3SNwJQS8BulKCPnfPQI/BQIyg/vGN75hNTU19uUvf/mimqQ1yttYHzt2zD0gZJ5y3333uX1ljiJ/kJlFhEmmK1pRKyz0axwzsVmo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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
460-517700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
641633
</td>
<td style="text-align:right;">
6049398
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
460-636000-36664-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
654312
</td>
<td style="text-align:right;">
6012383
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
460-185400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
605786
</td>
<td style="text-align:right;">
6099884
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
460-600600-07100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
643460
</td>
<td style="text-align:right;">
6025890
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
460-600600-36400-26300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
623369
</td>
<td style="text-align:right;">
6000283
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
400-448500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
582874
</td>
<td style="text-align:right;">
6130541
</td>
<td style="text-align:left;">
KISP
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
CT;DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
DV
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Bulkley
</th>
<th style="text-align:left;">
Kispiox
</th>
<th style="text-align:left;">
Kalum
</th>
<th style="text-align:left;">
Morice
</th>
<th style="text-align:left;">
Zymoetz
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus sardinella
</td>
<td style="text-align:left;">
Least Cisco
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Entosphenus tridentatus
</td>
<td style="text-align:left;">
Pacific Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Gasterosteus aculeatus
</td>
<td style="text-align:left;">
Threespine Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lampetra ayresii
</td>
<td style="text-align:left;">
River Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout (Anadromous)
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii clarkii
</td>
<td style="text-align:left;">
Coastal Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus keta
</td>
<td style="text-align:left;">
Chum Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Summer-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Winter-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
E/T/SC/DD/NAR (Nov 2020)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii pop. 3
</td>
<td style="text-align:left;">
Giant Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Pungitius pungitius
</td>
<td style="text-align:left;">
Ninespine Stickleback
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Cutthroat/Rainbow cross
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Verified DV BT hybrid
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
