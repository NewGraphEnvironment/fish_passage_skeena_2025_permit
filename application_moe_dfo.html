<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_skeena_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.com/fish_passage_skeena_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.com/fish_passage_skeena_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-25<br />
Date Revised: 2025-08-06</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit/raw/main/mapping/sites_skeena_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_skeena_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Habitat Trust Conservation Foundation, Ministry of Transportation and Infrastructure and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from the Office of Wet’suwet’en (contact Teagan Oshaughnessy - <a href="mailto:teagan.oshaughnessy@wetsuweten.com" class="email">teagan.oshaughnessy@wetsuweten.com</a> ) and Gitskan Watershed Authorities (contact Alicia Fernando - <a href="mailto:afernando@gitksanwatershed.com" class="email">afernando@gitksanwatershed.com</a> ). Previous reports are provided below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2020_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2021_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_bulkley_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2022_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2023_reporting/</a></li>
<li><a href="https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_skeena_2024_reporting/</a></li>
</ul>
<p><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, cutthrout trout, and dolly varden. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
460-517700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
641633
</td>
<td style="text-align:right;">
6049398
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
460-636000-36664-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
654312
</td>
<td style="text-align:right;">
6012383
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
460-185400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
605786
</td>
<td style="text-align:right;">
6099884
</td>
<td style="text-align:left;">
BULK
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
460-600600-07100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
643460
</td>
<td style="text-align:right;">
6025890
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
460-600600-36400-26300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
623369
</td>
<td style="text-align:right;">
6000283
</td>
<td style="text-align:left;">
MORR
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
400-448500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
582874
</td>
<td style="text-align:right;">
6130541
</td>
<td style="text-align:left;">
KISP
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
123377
</td>
<td style="text-align:left;">
Thompson Creek
</td>
<td style="text-align:left;">
CT;DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197640
</td>
<td style="text-align:left;">
Tributary To Buck Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197960
</td>
<td style="text-align:left;">
Corya Creek
</td>
<td style="text-align:left;">
DV;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
197962
</td>
<td style="text-align:left;">
Peacock Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198064
</td>
<td style="text-align:left;">
Tributary To Lamprey Creek
</td>
<td style="text-align:left;">
DV
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198217
</td>
<td style="text-align:left;">
Sik-E-Dakh
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 11px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Bulkley
</th>
<th style="text-align:left;">
Kispiox
</th>
<th style="text-align:left;">
Kalum
</th>
<th style="text-align:left;">
Morice
</th>
<th style="text-align:left;">
Zymoetz
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus sardinella
</td>
<td style="text-align:left;">
Least Cisco
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Entosphenus tridentatus
</td>
<td style="text-align:left;">
Pacific Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Gasterosteus aculeatus
</td>
<td style="text-align:left;">
Threespine Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lampetra ayresii
</td>
<td style="text-align:left;">
River Lamprey
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout (Anadromous)
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii clarkii
</td>
<td style="text-align:left;">
Coastal Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus keta
</td>
<td style="text-align:left;">
Chum Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Summer-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Steelhead (Winter-run)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
E/T/SC/DD/NAR (Nov 2020)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii pop. 3
</td>
<td style="text-align:left;">
Giant Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Pungitius pungitius
</td>
<td style="text-align:left;">
Ninespine Stickleback
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Arctic Char
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Cutthroat/Rainbow cross
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Stickleback (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Verified DV BT hybrid
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
